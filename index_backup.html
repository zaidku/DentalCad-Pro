

<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-900">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DentalCAD Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Three.js for 3D rendering -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    
    <!-- Dental Workflow System -->
    <script src="src/dentalWorkflow.js"></script>
    
    <!-- Dental Bases Module -->
    <script src="src/dentalBases.js"></script>
    <script src="src/dentalBaseUI.js"></script>
    
    <!-- Advanced Modeling Tools Module with Backend Integration -->
    <script src="src/modelingBackendService.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        dental: {
                            primary: '#f97316',
                            secondary: '#ea580c',
                            dark: '#0c0a09',
                            light: '#f5f5f4',
                            accent: '#fdba74',
                        },
                    },
                }
            }
        }
    </script>
    <style>
        .glass-effect {
            backdrop-filter: blur(16px) saturate(180%);
            -webkit-backdrop-filter: blur(16px) saturate(180%);
            background-color: rgba(15, 23, 42, 0.8);
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            outline: none;
        }

        .tool-button {
            transition: all 0.2s ease;
        }

            .tool-button.active {
                background-color: #f97316;
                color: white;
                box-shadow: 0 0 0 2px rgba(249, 115, 22, 0.5);
            }

        .property-input {
            background-color: rgba(31, 41, 55, 0.6);
            border: 1px solid rgba(55, 65, 81, 0.8);
        }

            .property-input:focus {
                border-color: #f97316;
                box-shadow: 0 0 0 1px #f97316;
            }

        .tab-content {
            display: none;
        }

            .tab-content.active {
                display: block;
            }

        /* STL upload dropzone */
        .dropzone {
            border: 2px dashed rgba(249, 115, 22, 0.3);
            transition: all 0.3s ease;
        }

            .dropzone.active {
                border-color: #f97316;
                background-color: rgba(249, 115, 22, 0.05);
            }

        /* Lasso drawing */
        .lasso-line {
            fill: none;
            stroke: #f97316;
            stroke-width: 2;
            stroke-dasharray: 5,5;
            opacity: 0.8;
        }
    </style>
</head>
<body class="h-full overflow-hidden text-gray-200">
    <div class="flex h-full">
        <!-- Sidebar -->
        <div class="w-16 bg-gray-900 border-r border-gray-800 flex flex-col items-center py-4 space-y-6">
            <!-- Logo -->
            <div class="w-10 h-10 rounded-md bg-dental-primary flex items-center justify-center text-white font-bold">
                DC
            </div>

            <!-- Tools -->
            <div class="flex flex-col items-center space-y-4 w-full">
                <button class="tool-button active w-12 h-12 rounded-lg flex items-center justify-center text-dental-primary hover:bg-gray-800" data-tool="select">
                    <i class="fas fa-mouse-pointer text-lg"></i>
                </button>

                <button class="tool-button w-12 h-12 rounded-lg flex items-center justify-center text-gray-400 hover:bg-gray-800 hover:text-dental-primary" data-tool="addMaterial">
                    <i class="fas fa-plus text-lg"></i>
                </button>

                <button class="tool-button w-12 h-12 rounded-lg flex items-center justify-center text-gray-400 hover:bg-gray-800 hover:text-dental-primary" data-tool="removeMaterial">
                    <i class="fas fa-minus text-lg"></i>
                </button>

                <button class="tool-button w-12 h-12 rounded-lg flex items-center justify-center text-gray-400 hover:bg-gray-800 hover:text-dental-primary" data-tool="smooth">
                    <i class="fas fa-magic text-lg"></i>
                </button>

                <button class="tool-button w-12 h-12 rounded-lg flex items-center justify-center text-gray-400 hover:bg-gray-800 hover:text-dental-primary" data-tool="measure">
                    <i class="fas fa-ruler-combined text-lg"></i>
                </button>

                <button class="tool-button w-12 h-12 rounded-lg flex items-center justify-center text-gray-400 hover:bg-gray-800 hover:text-dental-primary" data-tool="cut">
                    <i class="fas fa-cut text-lg"></i>
                </button>

                <button class="tool-button w-12 h-12 rounded-lg flex items-center justify-center text-gray-400 hover:bg-gray-800 hover:text-dental-primary" data-tool="rotate">
                    <i class="fas fa-sync-alt text-lg"></i>
                </button>

                <button id="dentalBaseButton" class="w-12 h-12 rounded-lg flex items-center justify-center text-gray-400 hover:bg-gray-800 hover:text-dental-primary" title="Add Dental Base">
                    <i class="fas fa-teeth text-lg"></i>
                </button>

                <button id="orientationButton" class="w-12 h-12 rounded-lg flex items-center justify-center text-gray-400 hover:bg-gray-800 hover:text-dental-primary" title="Model Orientation">
                    <i class="fas fa-compass text-lg"></i>
                </button>

                <button id="solidifyButton" class="w-12 h-12 rounded-lg flex items-center justify-center text-gray-400 hover:bg-gray-800 hover:text-dental-primary" title="Solidify Model">
                    <i class="fas fa-cube text-lg"></i>
                </button>

                <div class="border-t border-gray-800 w-8 mx-auto"></div>

                <button class="tool-button w-12 h-12 rounded-lg flex items-center justify-center text-gray-400 hover:bg-gray-800 hover:text-dental-primary" data-tool="layers">
                    <i class="fas fa-layer-group text-lg"></i>
                </button>
            </div>

            <div class="mt-auto flex flex-col items-center space-y-4">
                <button id="undoButton" class="w-12 h-12 rounded-lg flex items-center justify-center text-gray-400 hover:bg-gray-800 hover:text-dental-primary">
                    <i class="fas fa-undo text-lg"></i>
                </button>
                <button class="w-12 h-12 rounded-lg flex items-center justify-center text-gray-400 hover:bg-gray-800 hover:text-dental-primary">
                    <i class="fas fa-cog text-lg"></i>
                </button>
            </div>

            <div class="mt-auto flex flex-col items-center space-y-4">
                <button id="undoButton" class="w-12 h-12 rounded-lg flex items-center justify-center text-gray-400 hover:bg-gray-800 hover:text-dental-primary">
                    <i class="fas fa-undo text-lg"></i>
                </button>
                <button class="w-12 h-12 rounded-lg flex items-center justify-center text-gray-400 hover:bg-gray-800 hover:text-dental-primary">
                    <i class="fas fa-cog text-lg"></i>
                </button>
            </div>
        </div>

        <!-- Left Panel -->
        <div class="w-64 bg-gray-900 border-r border-gray-800 flex flex-col">
            <div class="p-4 border-b border-gray-800">
                <h2 class="font-semibold text-lg">Patient Case</h2>
                <div class="text-sm text-gray-400">Case #DC-2023-4872</div>
            </div>

            <div class="p-4 border-b border-gray-800">
                <div class="flex items-center space-x-3 mb-3">
                    <div class="w-10 h-10 rounded-full bg-dental-primary flex items-center justify-center text-white">
                        <i class="fas fa-user"></i>
                    </div>
                    <div>
                        <div class="font-medium">John Smith</div>
                        <div class="text-xs text-gray-400">Male, 42 years</div>
                    </div>
                </div>

                <div class="grid grid-cols-2 gap-2 text-xs mt-3">
                    <div class="bg-gray-800 rounded p-2">
                        <div class="text-gray-400">Last Visit</div>
                        <div>2023-06-15</div>
                    </div>
                    <div class="bg-gray-800 rounded p-2">
                        <div class="text-gray-400">Next Visit</div>
                        <div>2023-07-20</div>
                    </div>
                </div>
            </div>

            <div class="p-4 border-b border-gray-800">
                <h3 class="font-medium mb-2 flex items-center justify-between">
                    <span>Treatment Plan</span>
                    <button class="text-xs text-dental-primary hover:text-dental-secondary">Edit</button>
                </h3>

                <div class="space-y-2">
                    <div class="flex items-center space-x-2 p-2 bg-gray-800 rounded">
                        <div class="w-6 h-6 rounded-full bg-dental-primary flex items-center justify-center text-white text-xs">
                            14
                        </div>
                        <div class="text-sm">Crown - Zirconia</div>
                    </div>

                    <div class="flex items-center space-x-2 p-2 bg-gray-800 rounded">
                        <div class="w-6 h-6 rounded-full bg-dental-primary flex items-center justify-center text-white text-xs">
                            19
                        </div>
                        <div class="text-sm">Implant - Crown</div>
                    </div>

                    <div class="flex items-center space-x-2 p-2 bg-gray-800 rounded">
                        <div class="w-6 h-6 rounded-full bg-dental-primary flex items-center justify-center text-white text-xs">
                            30
                        </div>
                        <div class="text-sm">Onlay - Emax</div>
                    </div>
                </div>
            </div>

            <div class="p-4 border-b border-gray-800 flex-1">
                <h3 class="font-medium mb-2">Scan Files</h3>

                <div id="dropzone" class="dropzone rounded-lg p-4 mb-3 text-center cursor-pointer">
                    <i class="fas fa-cloud-upload-alt text-2xl text-dental-primary mb-2"></i>
                    <div class="text-sm">Drag & drop STL files here</div>
                    <div class="text-xs text-gray-500 mt-1">or click to browse</div>
                    <input type="file" id="fileInput" accept=".stl" class="hidden" multiple>
                </div>

                <div class="text-xs text-gray-400 mb-2">Uploaded Files:</div>
                <div id="uploadedFilesList" class="space-y-1 max-h-40 overflow-y-auto">
                    <div class="text-gray-500 text-sm italic" id="noFilesMessage">No files uploaded yet</div>
                </div>
            </div>

            <div class="p-4">
                <button id="workflowNextBtn" class="w-full bg-orange-600 hover:bg-orange-700 text-white py-2 px-4 rounded-lg flex items-center justify-center space-x-2">
                    <span>Next</span>
                    <i class="fas fa-arrow-right"></i>
                </button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="flex-1 flex flex-col bg-gray-900">
            <!-- Top Bar -->
            <div class="h-12 border-b border-gray-800 flex items-center px-4">
                <div class="flex items-center space-x-4">
                    <div class="text-sm bg-gray-800 rounded-full px-3 py-1 flex items-center space-x-1">
                        <span class="w-2 h-2 rounded-full bg-green-500"></span>
                        <span>Online</span>
                    </div>

                    <div class="text-sm text-gray-400">
                        Tool: <span id="toolStatus" class="text-dental-primary">Pencil</span>
                    </div>
                </div>

                <div class="ml-auto flex items-center space-x-3">
                    <button id="makePrintableButton" class="text-gray-400 hover:text-dental-primary" title="Make Printable (Thicken walls)">
                        <i class="fas fa-print"></i>
                    </button>
                    <button class="text-gray-400 hover:text-dental-primary">
                        <i class="fas fa-history"></i>
                    </button>
                    <button id="saveButton" class="text-gray-400 hover:text-dental-primary" title="Export STL">
                        <i class="fas fa-save"></i>
                    </button>
                    <button id="clearButton" class="text-gray-400 hover:text-red-500">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            </div>

            <!-- 3D Viewport -->
            <div class="flex-1 relative">
                <div id="renderCanvas"></div>
                <!-- SVG overlay for lasso drawing -->
                <svg id="lassoSVG" class="absolute top-0 left-0 w-full h-full pointer-events-none" style="z-index: 1000;">
                    <path id="lassoPath" class="lasso-line" d="" />
                </svg>

                <!-- Viewport Controls -->
                <div class="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-gray-800 rounded-full px-2 py-1 flex space-x-2">
                    <button id="resetViewBtn" class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-700" title="Reset View">
                        <i class="fas fa-rotate"></i>
                    </button>
                    <button id="panBtn" class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-700" title="Pan Mode">
                        <i class="fas fa-arrows-up-down-left-right"></i>
                    </button>
                    <button id="zoomInBtn" class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-700" title="Zoom In">
                        <i class="fas fa-search-plus"></i>
                    </button>
                    <button id="zoomOutBtn" class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-gray-700" title="Zoom Out">
                        <i class="fas fa-search-minus"></i>
                    </button>
                    <button id="toggleGridBtn" class="w-8 h-8 rounded-full flex items-center justify-center bg-dental-primary text-white" title="Toggle Grid">
                        <i class="fas fa-cube"></i>
                    </button>
                </div>

                <!-- Viewport Options -->
                <div class="absolute top-4 right-4 bg-gray-800 rounded-lg p-2">
                    <div class="grid grid-cols-2 gap-2">
                        <button id="wireframeBtn" class="viewport-btn px-3 py-1 rounded text-xs bg-gray-700 hover:bg-gray-600" data-mode="wireframe">Wireframe</button>
                        <button id="solidBtn" class="viewport-btn px-3 py-1 rounded text-xs bg-gray-700 hover:bg-gray-600" data-mode="solid">Solid</button>
                        <button id="shadedBtn" class="viewport-btn px-3 py-1 rounded text-xs bg-dental-primary text-white" data-mode="shaded">Shaded</button>
                        <button id="xrayBtn" class="viewport-btn px-3 py-1 rounded text-xs bg-gray-700 hover:bg-gray-600" data-mode="xray">X-ray</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="w-80 bg-gray-900 border-l border-gray-800 flex flex-col">
            <div class="p-4 border-b border-gray-800">
                <div class="flex space-x-2">
                    <button class="tab-button active px-3 py-1 rounded text-sm bg-dental-primary text-white">Design</button>
                    <button class="tab-button px-3 py-1 rounded text-sm bg-gray-800 hover:bg-gray-700">Materials</button>
                    <button class="tab-button px-3 py-1 rounded text-sm bg-gray-800 hover:bg-gray-700">Layers</button>
                </div>
            </div>

            <div class="flex-1 overflow-y-auto">
                <!-- Design Tab -->
                <div class="tab-content active p-4 space-y-6">
                    <div>
                        <h3 class="font-medium mb-3 flex items-center justify-between">
                            <span>Tooth #14</span>
                            <span class="text-xs bg-dental-primary text-white px-2 py-1 rounded-full">Crown</span>
                        </h3>

                        <div class="space-y-4">
                            <div>
                                <label class="block text-xs text-gray-400 mb-1">Restoration Type</label>
                                <select class="w-full property-input rounded px-3 py-2 text-sm">
                                    <option>Crown</option>
                                    <option>Bridge</option>
                                    <option>Veneer</option>
                                    <option>Inlay</option>
                                    <option>Onlay</option>
                                </select>
                            </div>

                            <div>
                                <label class="block text-xs text-gray-400 mb-1">Margin Line</label>
                                <div class="flex space-x-2">
                                    <div class="color-option w-6 h-6 rounded-full bg-red-500 border-2 border-transparent cursor-pointer"></div>
                                    <div class="color-option w-6 h-6 rounded-full bg-orange-500 border-2 border-transparent cursor-pointer"></div>
                                    <div class="color-option w-6 h-6 rounded-full bg-yellow-500 border-2 border-transparent cursor-pointer"></div>
                                    <div class="color-option w-6 h-6 rounded-full bg-green-500 border-2 border-transparent cursor-pointer"></div>
                                    <div class="color-option w-6 h-6 rounded-full bg-blue-500 border-2 border-transparent cursor-pointer selected"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div>
                        <h3 class="font-medium mb-3">Dimensions</h3>

                        <div class="space-y-4">
                            <div>
                                <label class="block text-xs text-gray-400 mb-1">Occlusal Thickness (mm)</label>
                                <div class="flex items-center space-x-3">
                                    <input type="range" min="0.5" max="2.0" step="0.1" value="1.2" class="w-full property-input">
                                    <span class="text-xs w-8 text-center">1.2</span>
                                </div>
                            </div>

                            <div>
                                <label class="block text-xs text-gray-400 mb-1">Marginal Width (mm)</label>
                                <div class="flex items-center space-x-3">
                                    <input type="range" min="0.3" max="1.5" step="0.1" value="0.8" class="w-full property-input">
                                    <span class="text-xs w-8 text-center">0.8</span>
                                </div>
                            </div>

                            <div>
                                <label class="block text-xs text-gray-400 mb-1">Contact Points</label>
                                <div class="grid grid-cols-3 gap-2">
                                    <button class="py-1 rounded text-xs bg-gray-800 hover:bg-gray-700">Mesial</button>
                                    <button class="py-1 rounded text-xs bg-dental-primary text-white">Distal</button>
                                    <button class="py-1 rounded text-xs bg-gray-800 hover:bg-gray-700">Both</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div>
                        <h3 class="font-medium mb-3">Material</h3>

                        <div class="grid grid-cols-3 gap-2">
                            <div class="material-option p-2 rounded bg-gray-800 hover:bg-gray-700 cursor-pointer text-center">
                                <div class="w-8 h-8 rounded-full bg-white mx-auto mb-1"></div>
                                <div class="text-xs">Zirconia</div>
                            </div>
                            <div class="material-option p-2 rounded bg-gray-800 hover:bg-gray-700 cursor-pointer text-center">
                                <div class="w-8 h-8 rounded-full bg-yellow-100 mx-auto mb-1"></div>
                                <div class="text-xs">Emax</div>
                            </div>
                            <div class="material-option p-2 rounded bg-gray-800 hover:bg-gray-700 cursor-pointer text-center">
                                <div class="w-8 h-8 rounded-full bg-amber-200 mx-auto mb-1"></div>
                                <div class="text-xs">PFM</div>
                            </div>
                            <div class="material-option p-2 rounded bg-gray-800 hover:bg-gray-700 cursor-pointer text-center">
                                <div class="w-8 h-8 rounded-full bg-yellow-300 mx-auto mb-1"></div>
                                <div class="text-xs">Gold</div>
                            </div>
                            <div class="material-option p-2 rounded bg-gray-800 hover:bg-gray-700 cursor-pointer text-center">
                                <div class="w-8 h-8 rounded-full bg-blue-50 mx-auto mb-1"></div>
                                <div class="text-xs">Composite</div>
                            </div>
                            <div class="material-option p-2 rounded bg-gray-800 hover:bg-gray-700 cursor-pointer text-center">
                                <div class="w-8 h-8 rounded-full bg-gray-200 mx-auto mb-1 flex items-center justify-center">
                                    <i class="fas fa-plus text-xs"></i>
                                </div>
                                <div class="text-xs">Custom</div>
                            </div>
                        </div>

                        <div class="mt-3">
                            <label class="block text-xs text-gray-400 mb-1">Material Thickness (mm)</label>
                            <div class="flex items-center space-x-3">
                                <input type="range" min="0.3" max="2.0" step="0.1" value="1.0" class="w-full property-input">
                                <span class="text-xs w-8 text-center">1.0</span>
                            </div>
                        </div>
                    </div>

                    <div>
                        <h3 class="font-medium mb-3">Tool Settings</h3>
                        
                        <div class="space-y-4">
                            <div>
                                <label class="block text-xs text-gray-400 mb-1">Tool Strength</label>
                                <div class="flex items-center space-x-3">
                                    <input type="range" id="strengthSlider" min="0.01" max="0.4" step="0.01" value="0.2" class="w-full property-input">
                                    <span id="strengthValue" class="text-xs w-8 text-center">0.20</span>
                                </div>
                            </div>

                            <div>
                                <label class="block text-xs text-gray-400 mb-1">Influence Size (mm)</label>
                                <div class="flex items-center space-x-3">
                                    <input type="range" id="influenceSizeSlider" min="0.1" max="2.0" step="0.1" value="1.0" class="w-full property-input">
                                    <span id="influenceSizeValue" class="text-xs w-8 text-center">1.0</span>
                                </div>
                            </div>

                            <div class="flex items-center justify-between">
                                <label class="text-xs text-gray-400">Show Tool Info</label>
                                <input type="checkbox" id="showToolInfo" checked class="text-dental-primary">
                            </div>

                            <div class="flex items-center justify-between">
                                <label class="text-xs text-gray-400">Show Grid</label>
                                <input type="checkbox" id="showGrid" checked class="text-dental-primary">
                            </div>

                            <div class="text-xs text-gray-400 mt-3">
                                <div><strong>Instructions:</strong></div>
                                <div>• Select: Click model to select (highlighted)</div>
                                <div>• Cut: Left-click + drag lasso to cut area</div>
                                <div>• Add/Remove: Left-click + drag to sculpt</div>
                                <div>• Smooth: Left-click + drag to smooth</div>
                                <div>• Rotate: Click axis rings for constrained rotation (Red=X, Green=Y, Blue=Z)</div>
                                <div>• Right-click + drag: Rotate view</div>
                                <div>• Print button: Add dental base + thicken walls for 3D printing</div>
                            </div>
                        </div>
                    </div>

                    <!-- Advanced Modeling Tools Section -->
                    <div id="modelingToolsContainer">
                        <div class="bg-gray-800 p-4 rounded-lg border border-gray-600">
                            <h3 class="text-lg font-bold text-white mb-4">
                                <i class="fas fa-cogs mr-2"></i>
                                Advanced Modeling Tools
                            </h3>
                            
                            <!-- Backend Status -->
                            <div id="backendStatus" class="mb-4 p-3 rounded text-sm bg-gray-700 text-gray-300">
                                <i class="fas fa-server mr-2"></i>
                                <span id="backendStatusText">Checking backend service...</span>
                            </div>
                            
                            <!-- Model Orientation Controls -->
                            <div class="mb-6">
                                <div class="flex items-center mb-3">
                                    <i class="fas fa-compass text-blue-400 mr-2"></i>
                                    <label class="text-sm font-semibold text-gray-300">Model Orientation</label>
                                </div>
                                
                                <!-- Preset Orientations -->
                                <div class="grid grid-cols-2 gap-2 mb-3">
                                    <button id="orientOcclusalUp" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded text-sm disabled:bg-gray-600 disabled:cursor-not-allowed">
                                        <i class="fas fa-arrow-up mr-1"></i>Occlusal Up
                                    </button>
                                    <button id="orientOcclusalDown" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded text-sm disabled:bg-gray-600 disabled:cursor-not-allowed">
                                        <i class="fas fa-arrow-down mr-1"></i>Occlusal Down
                                    </button>
                                    <button id="orientBuccalFront" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded text-sm disabled:bg-gray-600 disabled:cursor-not-allowed">
                                        <i class="fas fa-eye mr-1"></i>Buccal View
                                    </button>
                                    <button id="orientLingualView" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-2 rounded text-sm disabled:bg-gray-600 disabled:cursor-not-allowed">
                                        <i class="fas fa-eye-slash mr-1"></i>Lingual View
                                    </button>
                                </div>
                                
                                <!-- Custom Orientation -->
                                <div class="bg-gray-700 p-3 rounded mt-3">
                                    <label class="text-xs text-gray-400 mb-2 block">Custom Rotation (degrees)</label>
                                    <div class="grid grid-cols-3 gap-2 mb-2">
                                        <input type="number" id="rotationX" class="bg-gray-600 text-white px-2 py-1 rounded text-sm" placeholder="X" value="0" min="-180" max="180">
                                        <input type="number" id="rotationY" class="bg-gray-600 text-white px-2 py-1 rounded text-sm" placeholder="Y" value="0" min="-180" max="180">
                                        <input type="number" id="rotationZ" class="bg-gray-600 text-white px-2 py-1 rounded text-sm" placeholder="Z" value="0" min="-180" max="180">
                                    </div>
                                    <button id="applyCustomOrientation" class="w-full bg-purple-600 hover:bg-purple-700 text-white px-3 py-2 rounded text-sm disabled:bg-gray-600 disabled:cursor-not-allowed">
                                        <i class="fas fa-sync-alt mr-1"></i>Apply Custom
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Model Solidification -->
                            <div class="mb-4">
                                <div class="flex items-center mb-3">
                                    <i class="fas fa-cube text-green-400 mr-2"></i>
                                    <label class="text-sm font-semibold text-gray-300">Model Solidification</label>
                                </div>
                                
                                <div class="bg-gray-700 p-3 rounded">
                                    <label class="text-xs text-gray-400 mb-2 block">Wall Thickness (mm)</label>
                                    <div class="flex items-center gap-2 mb-3">
                                        <input type="range" id="extrusionDepth" class="flex-1" min="0.5" max="5.0" step="0.1" value="2.0">
                                        <input type="number" id="extrusionDepthValue" class="bg-gray-600 text-white px-2 py-1 rounded text-sm w-16" value="2.0" min="0.5" max="5.0" step="0.1">
                                    </div>
                                    <button id="applySolidification" class="w-full bg-green-600 hover:bg-green-700 text-white px-3 py-2 rounded text-sm disabled:bg-gray-600 disabled:cursor-not-allowed">
                                        <i class="fas fa-magic mr-1"></i>Solidify Model
                                    </button>
                                    <p class="text-xs text-gray-400 mt-2">Creates solid model by adding internal walls</p>
                                </div>
                            </div>

                            <!-- Processing Status -->
                            <div id="modelingStatus" class="bg-gray-700 p-3 rounded text-sm text-gray-300">
                                <i class="fas fa-info-circle mr-2"></i>
                                <span id="modelingStatusText">Waiting for backend service...</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Materials Tab -->
                <div class="tab-content p-4">
                    <div class="text-center text-gray-400 py-8">
                        <i class="fas fa-box-open text-2xl mb-2"></i>
                        <div>Material library</div>
                    </div>
                </div>

                <!-- Layers Tab -->
                <div class="tab-content p-4">
                    <div class="text-center text-gray-400 py-8">
                        <i class="fas fa-layer-group text-2xl mb-2"></i>
                        <div>Layer management</div>
                    </div>
                </div>
            </div>

            <div class="p-4 border-t border-gray-800">
                <button class="w-full bg-dental-primary hover:bg-dental-secondary text-white py-2 px-4 rounded-lg">
                    Apply Changes
                </button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let loadedModels = [];
        let selectedModel = null; // Currently selected model
        let activeTool = 'select';
        let isDrawing = false;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let undoStack = [];
        let maxUndoSteps = 20;
        let lassoPoints = [];
        let currentLassoPath = '';
        let gridHelper; // Store grid helper reference
        let rotationGizmo = null; // Rotation gizmo object
        let rotationAxis = null; // Currently selected rotation axis (x, y, z)
        let initialQuaternion = null; // Store initial rotation for smooth transitions
        let rotationPlane = null; // Visual plane for rotation feedback
        let previousAngle = 0; // Store previous angle for smooth rotation
        
        // Tool settings
        let toolSettings = {
            strength: 0.2,
            influenceSize: 1.0,
            showToolInfo: true,
            showGrid: true
        };

        // Viewport settings
        let currentViewportMode = 'shaded';
        let isGridVisible = true;

        // Initialize Three.js scene
        function init3DViewer() {
            console.log('🎯 Initializing 3D viewer...');
            
            // Check if Three.js is loaded
            if (typeof THREE === 'undefined') {
                console.error('❌ Three.js not loaded!');
                return;
            }
            
            console.log('✅ Three.js version:', THREE.REVISION);
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0c0a09);
            scene.add(new THREE.AmbientLight(0x404040, 0.4));

            // Create camera
            const container = document.getElementById('renderCanvas');
            camera = new THREE.PerspectiveCamera(75, container.offsetWidth / container.offsetHeight, 0.1, 1000);
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);
            console.log('📹 Camera positioned at:', camera.position);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.offsetWidth, container.offsetHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // Add orbit controls with custom mouse button configuration
            if (!THREE.OrbitControls) {
                console.error('❌ OrbitControls not available. Loaders may not have loaded yet.');
                return;
            }
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.mouseButtons = {
                LEFT: null, // Disable left-click for orbit
                MIDDLE: THREE.MOUSE.DOLLY,
                RIGHT: THREE.MOUSE.ROTATE
            };
            controls.touches = {
                ONE: THREE.TOUCH.ROTATE,
                TWO: THREE.TOUCH.DOLLY_PAN
            };

            // Add lights
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            scene.add(hemisphereLight);

            // Add grid helper
            console.log('🟩 Creating grid helper...');
            gridHelper = new THREE.GridHelper(100, 100, 0x888888, 0x444444);
            gridHelper.position.y = -10;
            scene.add(gridHelper);
            console.log('✅ Grid helper added to scene:', gridHelper);

            // Handle window resize
            window.addEventListener('resize', onWindowResize);

            // Setup mouse events
            setupMouseEvents();

            // Start animation loop
            animate();
            
            console.log('✅ 3D viewer initialized');
        }

        function onWindowResize() {
            const container = document.getElementById('renderCanvas');
            camera.aspect = container.offsetWidth / container.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.offsetWidth, container.offsetHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Manual render function for immediate updates
        function render() {
            if (renderer && scene && camera) {
                controls.update();
                renderer.render(scene, camera);
            }
        }

        // Tool management
        function selectTool(toolName) {
            activeTool = toolName;
            
            // Update UI
            document.querySelectorAll('.tool-button').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-tool="${toolName}"]`).classList.add('active');
            
            // Update tool status
            const toolNames = {
                'select': selectedModel ? `Select (${selectedModel.userData.filename || 'Model'} selected)` : 'Select (Click model to select)',
                'addMaterial': `Add Material (Size: ${toolSettings.influenceSize.toFixed(1)}mm)`,
                'removeMaterial': `Remove Material (Size: ${toolSettings.influenceSize.toFixed(1)}mm)`,
                'smooth': `Smooth (Size: ${toolSettings.influenceSize.toFixed(1)}mm)`,
                'measure': 'Measure (Click two points)',
                'cut': 'Cut (Left-click+drag lasso to cut area)',
                'rotate': selectedModel ? `Rotate (${selectedModel.userData.filename || 'Model'})` : 'Rotate (Select model first)',
                'layers': 'Layers'
            };
            
            document.getElementById('toolStatus').textContent = toolNames[toolName] || toolName;
            
            // Configure controls based on tool
            if (['select', 'cut', 'addMaterial', 'removeMaterial', 'smooth', 'rotate'].includes(toolName)) {
                // Tool mode - left click is reserved for tool operations
                controls.mouseButtons.LEFT = null;
                controls.enabled = true; // Keep orbit controls enabled for right-click
            } else {
                // Navigation mode - left click can rotate
                controls.mouseButtons.LEFT = THREE.MOUSE.ROTATE;
                controls.enabled = true;
            }
            
            // Show/hide rotation gizmo
            if (toolName === 'rotate' && selectedModel) {
                createRotationGizmo();
            } else {
                hideRotationGizmo();
            }
            
            console.log('🔧 Tool changed to:', toolName);
        }

        // Rotation Gizmo functions
        function createRotationGizmo() {
            if (rotationGizmo) {
                scene.remove(rotationGizmo);
                rotationGizmo = null;
            }
            
            if (!selectedModel) return;
            
            rotationGizmo = new THREE.Group();
            
            // Get model's bounding box for proper gizmo sizing
            selectedModel.geometry.computeBoundingBox();
            const bbox = selectedModel.geometry.boundingBox;
            const size = Math.max(
                bbox.max.x - bbox.min.x,
                bbox.max.y - bbox.min.y,
                bbox.max.z - bbox.min.z
            ) * 0.7; // Scale gizmo to 70% of model size
            
            // Create axis rings with better geometry
            const ringGeometry = new THREE.TorusGeometry(size, size * 0.035, 16, 64);
            
            // X-axis ring (Red) - rotates around X axis
            const xRingMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff4444, 
                transparent: true, 
                opacity: 0.95,
                side: THREE.DoubleSide,
                depthTest: false,
                depthWrite: false
            });
            const xRing = new THREE.Mesh(ringGeometry, xRingMaterial);
            xRing.rotation.y = Math.PI / 2;
            xRing.userData = { axis: 'x', originalColor: 0xff4444 };
            xRing.renderOrder = 1000; // Render on top
            rotationGizmo.add(xRing);
            
            // Add arrow indicators for X-axis (positioned on the ring)
            const arrowGeometry = new THREE.ConeGeometry(size * 0.04, size * 0.12, 8);
            const xArrow1 = new THREE.Mesh(arrowGeometry, xRingMaterial.clone());
            xArrow1.position.set(0, size * 0.8, 0); // Position on the ring
            xArrow1.rotation.z = -Math.PI / 2;
            xArrow1.userData = { axis: 'x', originalColor: 0xff4444 };
            xArrow1.renderOrder = 1001; // Render above ring
            rotationGizmo.add(xArrow1);
            
            const xArrow2 = new THREE.Mesh(arrowGeometry, xRingMaterial.clone());
            xArrow2.position.set(0, -size * 0.8, 0);
            xArrow2.rotation.z = Math.PI / 2;
            xArrow2.userData = { axis: 'x', originalColor: 0xff4444 };
            xArrow2.renderOrder = 1001;
            rotationGizmo.add(xArrow2);
            
            const xArrow3 = new THREE.Mesh(arrowGeometry, xRingMaterial.clone());
            xArrow3.position.set(0, 0, size * 0.8);
            xArrow3.rotation.x = Math.PI / 2;
            xArrow3.userData = { axis: 'x', originalColor: 0xff4444 };
            xArrow3.renderOrder = 1001;
            rotationGizmo.add(xArrow3);
            
            const xArrow4 = new THREE.Mesh(arrowGeometry, xRingMaterial.clone());
            xArrow4.position.set(0, 0, -size * 0.8);
            xArrow4.rotation.x = -Math.PI / 2;
            xArrow4.userData = { axis: 'x', originalColor: 0xff4444 };
            xArrow4.renderOrder = 1001;
            rotationGizmo.add(xArrow4);
            
            // Y-axis ring (Green) - rotates around Y axis
            const yRingMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x44ff44, 
                transparent: true, 
                opacity: 0.95,
                side: THREE.DoubleSide,
                depthTest: false,
                depthWrite: false
            });
            const yRing = new THREE.Mesh(ringGeometry, yRingMaterial);
            yRing.userData = { axis: 'y', originalColor: 0x44ff44 };
            yRing.renderOrder = 1000; // Render on top
            rotationGizmo.add(yRing);
            
            // Add arrow indicators for Y-axis (positioned on the ring)
            const yArrow1 = new THREE.Mesh(arrowGeometry, yRingMaterial.clone());
            yArrow1.position.set(size * 0.8, 0, 0); // Position on the ring
            yArrow1.rotation.z = Math.PI;
            yArrow1.userData = { axis: 'y', originalColor: 0x44ff44 };
            yArrow1.renderOrder = 1001;
            rotationGizmo.add(yArrow1);
            
            const yArrow2 = new THREE.Mesh(arrowGeometry, yRingMaterial.clone());
            yArrow2.position.set(-size * 0.8, 0, 0);
            yArrow2.rotation.z = 0;
            yArrow2.userData = { axis: 'y', originalColor: 0x44ff44 };
            yArrow2.renderOrder = 1001;
            rotationGizmo.add(yArrow2);
            
            const yArrow3 = new THREE.Mesh(arrowGeometry, yRingMaterial.clone());
            yArrow3.position.set(0, 0, size * 0.8);
            yArrow3.rotation.x = Math.PI / 2;
            yArrow3.rotation.z = Math.PI / 2;
            yArrow3.userData = { axis: 'y', originalColor: 0x44ff44 };
            yArrow3.renderOrder = 1001;
            rotationGizmo.add(yArrow3);
            
            const yArrow4 = new THREE.Mesh(arrowGeometry, yRingMaterial.clone());
            yArrow4.position.set(0, 0, -size * 0.8);
            yArrow4.rotation.x = -Math.PI / 2;
            yArrow4.rotation.z = Math.PI / 2;
            yArrow4.userData = { axis: 'y', originalColor: 0x44ff44 };
            yArrow4.renderOrder = 1001;
            rotationGizmo.add(yArrow4);
            
            // Z-axis ring (Blue) - rotates around Z axis
            const zRingMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x4444ff, 
                transparent: true, 
                opacity: 0.95,
                side: THREE.DoubleSide,
                depthTest: false,
                depthWrite: false
            });
            const zRing = new THREE.Mesh(ringGeometry, zRingMaterial);
            zRing.rotation.x = Math.PI / 2;
            zRing.userData = { axis: 'z', originalColor: 0x4444ff };
            zRing.renderOrder = 1000; // Render on top
            rotationGizmo.add(zRing);
            
            // Add arrow indicators for Z-axis (positioned on the ring)
            const zArrow1 = new THREE.Mesh(arrowGeometry, zRingMaterial.clone());
            zArrow1.position.set(size * 0.8, 0, 0); // Position on the ring
            zArrow1.rotation.y = -Math.PI / 2;
            zArrow1.userData = { axis: 'z', originalColor: 0x4444ff };
            zArrow1.renderOrder = 1001;
            rotationGizmo.add(zArrow1);
            
            const zArrow2 = new THREE.Mesh(arrowGeometry, zRingMaterial.clone());
            zArrow2.position.set(-size * 0.8, 0, 0);
            zArrow2.rotation.y = Math.PI / 2;
            zArrow2.userData = { axis: 'z', originalColor: 0x4444ff };
            zArrow2.renderOrder = 1001;
            rotationGizmo.add(zArrow2);
            
            const zArrow3 = new THREE.Mesh(arrowGeometry, zRingMaterial.clone());
            zArrow3.position.set(0, size * 0.8, 0);
            zArrow3.rotation.z = -Math.PI / 2;
            zArrow3.rotation.y = Math.PI / 2;
            zArrow3.userData = { axis: 'z', originalColor: 0x4444ff };
            zArrow3.renderOrder = 1001;
            rotationGizmo.add(zArrow3);
            
            const zArrow4 = new THREE.Mesh(arrowGeometry, zRingMaterial.clone());
            zArrow4.position.set(0, -size * 0.8, 0);
            zArrow4.rotation.z = Math.PI / 2;
            zArrow4.rotation.y = Math.PI / 2;
            zArrow4.userData = { axis: 'z', originalColor: 0x4444ff };
            zArrow4.renderOrder = 1001;
            rotationGizmo.add(zArrow4);
            
            // Add center sphere for free rotation
            const centerGeometry = new THREE.SphereGeometry(size * 0.1, 16, 16);
            const centerMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.6,
                depthTest: false
            });
            const centerSphere = new THREE.Mesh(centerGeometry, centerMaterial);
            centerSphere.userData = { axis: 'free' };
            centerSphere.renderOrder = 1001;
            rotationGizmo.add(centerSphere);
            
            // Position gizmo at model center
            const modelCenter = new THREE.Vector3();
            bbox.getCenter(modelCenter);
            rotationGizmo.position.copy(modelCenter);
            
            // Ensure all gizmo objects have proper geometry computations for raycasting
            rotationGizmo.traverse((child) => {
                if (child.isMesh) {
                    child.geometry.computeBoundingBox();
                    child.geometry.computeBoundingSphere();
                    child.matrixAutoUpdate = true;
                    child.updateMatrix();
                    child.updateMatrixWorld(true);
                }
            });
            
            scene.add(rotationGizmo);
            
            // Force update scene matrices
            scene.updateMatrixWorld(true);
            
            console.log('🎯 Enhanced rotation gizmo created at position:', rotationGizmo.position);
            console.log('🎯 Gizmo has', rotationGizmo.children.length, 'children ready for interaction');
        }

        function hideRotationGizmo() {
            if (rotationGizmo) {
                scene.remove(rotationGizmo);
                rotationGizmo = null;
                rotationAxis = null;
                initialQuaternion = null;
                hideRotationPlane();
                console.log('🎯 Rotation gizmo hidden');
            }
        }

        function highlightGizmoAxis(axis) {
            if (!rotationGizmo) return;
            
            // Reset all axes to normal state
            rotationGizmo.children.forEach(element => {
                if (element.userData.originalColor && element.material) {
                    if (element.material.color) element.material.color.setHex(element.userData.originalColor);
                    if (element.material.opacity !== undefined) element.material.opacity = 0.95;
                    if (element.material.emissive) element.material.emissive.setHex(0x000000);
                    element.scale.set(1, 1, 1);
                }
            });
            
            // Highlight selected axis (including arrows)
            if (axis && axis !== 'free') {
                const targetElements = rotationGizmo.children.filter(element => element.userData.axis === axis);
                targetElements.forEach(element => {
                    if (element.material) {
                        if (element.material.color) element.material.color.setHex(0xffffff);
                        if (element.material.opacity !== undefined) element.material.opacity = 1.0;
                        if (element.material.emissive) element.material.emissive.setHex(0x444444);
                        element.scale.set(1.3, 1.3, 1.3); // Scale up selected axis and arrows
                    }
                });
                showRotationPlane(axis);
            } else if (axis === 'free') {
                const centerSphere = rotationGizmo.children.find(element => element.userData.axis === 'free');
                if (centerSphere && centerSphere.material) {
                    if (centerSphere.material.color) centerSphere.material.color.setHex(0xffff00);
                    if (centerSphere.material.opacity !== undefined) centerSphere.material.opacity = 1.0;
                }
            } else {
                hideRotationPlane();
            }
        }

        function showRotationPlane(axis) {
            hideRotationPlane();
            
            if (!selectedModel || !rotationGizmo) return;
            
            const size = Math.max(
                selectedModel.geometry.boundingBox.max.x - selectedModel.geometry.boundingBox.min.x,
                selectedModel.geometry.boundingBox.max.y - selectedModel.geometry.boundingBox.min.y,
                selectedModel.geometry.boundingBox.max.z - selectedModel.geometry.boundingBox.min.z
            ) * 1.2;
            
            const planeGeometry = new THREE.CircleGeometry(size, 64);
            const planeMaterial = new THREE.MeshBasicMaterial({
                color: axis === 'x' ? 0xff4444 : axis === 'y' ? 0x44ff44 : 0x4444ff,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide,
                depthTest: false
            });
            
            rotationPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            
            // Orient plane based on rotation axis
            if (axis === 'x') {
                rotationPlane.rotation.y = Math.PI / 2;
            } else if (axis === 'z') {
                rotationPlane.rotation.x = Math.PI / 2;
            }
            // Y axis plane is already in correct orientation
            
            rotationPlane.position.copy(rotationGizmo.position);
            rotationPlane.renderOrder = 999;
            scene.add(rotationPlane);
        }

        function hideRotationPlane() {
            if (rotationPlane) {
                scene.remove(rotationPlane);
                rotationPlane = null;
            }
        }

        // Model selection functions
        function selectModel(model) {
            // Clear previous selection
            if (selectedModel) {
                selectedModel.material.emissive.setHex(0x000000);
            }
            
            // Select new model
            selectedModel = model;
            if (selectedModel) {
                selectedModel.material.emissive.setHex(0x333333); // Highlight selected model
                console.log('📦 Model selected:', selectedModel.userData.filename || 'Unnamed');
            }
            
            // Update tool status if using select or rotate tool
            if (['select', 'rotate'].includes(activeTool)) {
                selectTool(activeTool); // Refresh the tool status display
            }
            
            // Refresh rotation gizmo if rotate tool is active
            if (activeTool === 'rotate') {
                createRotationGizmo();
            }
        }

        function toggleModelVisibility(model) {
            model.visible = !model.visible;
            console.log('👁️ Model visibility:', model.visible ? 'shown' : 'hidden');
        }

        // Viewport control functions
        function setViewportMode(mode) {
            currentViewportMode = mode;
            
            // Update button states
            document.querySelectorAll('.viewport-btn').forEach(btn => {
                btn.classList.remove('bg-dental-primary', 'text-white');
                btn.classList.add('bg-gray-700');
            });
            
            const activeBtn = document.querySelector(`[data-mode="${mode}"]`);
            if (activeBtn) {
                activeBtn.classList.remove('bg-gray-700');
                activeBtn.classList.add('bg-dental-primary', 'text-white');
            }
            
            // Apply viewport mode to all loaded models
            loadedModels.forEach(model => {
                switch (mode) {
                    case 'wireframe':
                        model.material.wireframe = true;
                        model.material.transparent = false;
                        model.material.opacity = 1.0;
                        break;
                    case 'solid':
                        model.material.wireframe = false;
                        model.material.transparent = false;
                        model.material.opacity = 1.0;
                        // Use flat shading for solid mode
                        model.material.flatShading = true;
                        break;
                    case 'shaded':
                        model.material.wireframe = false;
                        model.material.transparent = false;
                        model.material.opacity = 1.0;
                        model.material.flatShading = false;
                        break;
                    case 'xray':
                        model.material.wireframe = false;
                        model.material.transparent = true;
                        model.material.opacity = 0.3;
                        model.material.flatShading = false;
                        break;
                }
                model.material.needsUpdate = true;
            });
            
            console.log('🎨 Viewport mode changed to:', mode);
        }

        function toggleGrid() {
            isGridVisible = !isGridVisible;
            toolSettings.showGrid = isGridVisible;
            
            if (gridHelper) {
                gridHelper.visible = isGridVisible;
            }
            
            // Update grid button state
            const gridBtn = document.getElementById('toggleGridBtn');
            if (gridBtn) {
                if (isGridVisible) {
                    gridBtn.classList.add('bg-dental-primary', 'text-white');
                    gridBtn.classList.remove('bg-gray-700');
                } else {
                    gridBtn.classList.remove('bg-dental-primary', 'text-white');
                    gridBtn.classList.add('bg-gray-700');
                }
            }
            
            // Sync with checkbox
            const showGridCheckbox = document.getElementById('showGrid');
            if (showGridCheckbox) {
                showGridCheckbox.checked = isGridVisible;
            }
            
            console.log('📐 Grid visibility:', isGridVisible ? 'shown' : 'hidden');
        }

        function resetView() {
            if (selectedModel) {
                fitCameraToObject(camera, controls, selectedModel, 1.5);
            } else if (loadedModels.length > 0) {
                fitCameraToObject(camera, controls, loadedModels[0], 1.5);
            } else {
                // Reset to default camera position
                camera.position.set(0, 0, 50);
                controls.target.set(0, 0, 0);
                controls.update();
            }
            console.log('🔄 View reset');
        }

        function zoomIn() {
            const currentDistance = camera.position.distanceTo(controls.target);
            const newDistance = currentDistance * 0.8;
            const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
            camera.position.copy(controls.target).add(direction.multiplyScalar(newDistance));
            controls.update();
            console.log('🔍 Zoomed in');
        }

        function zoomOut() {
            const currentDistance = camera.position.distanceTo(controls.target);
            const newDistance = currentDistance * 1.25;
            const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
            camera.position.copy(controls.target).add(direction.multiplyScalar(newDistance));
            controls.update();
            console.log('🔍 Zoomed out');
        }

        // Mouse event handling
        function setupMouseEvents() {
            const canvas = renderer.domElement;
            
            canvas.addEventListener('mousedown', onMouseDown, false);
            canvas.addEventListener('mousemove', onMouseMove, false);
            canvas.addEventListener('mouseup', onMouseUp, false);
            canvas.addEventListener('contextmenu', (e) => e.preventDefault()); // Prevent right-click menu
        }

        function onMouseDown(event) {
            if (event.button !== 0) return; // Only left click for tools
            
            console.log('🖱️ Mouse down - Tool:', activeTool, 'Button:', event.button);
            
            if (['select', 'cut', 'addMaterial', 'removeMaterial', 'smooth', 'rotate'].includes(activeTool)) {
                event.preventDefault();
                event.stopPropagation();
                
                // Get mouse coordinates
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                console.log('🖱️ Mouse coords:', mouse.x, mouse.y);
                
                // For rotate tool, first check if clicking on gizmo
                if (activeTool === 'rotate' && rotationGizmo) {
                    console.log('🎯 Checking gizmo intersection...');
                    console.log('🎯 Gizmo children count:', rotationGizmo.children.length);
                    console.log('🎯 Mouse coordinates:', mouse.x.toFixed(3), mouse.y.toFixed(3));
                    console.log('🎯 Camera position:', camera.position.x.toFixed(2), camera.position.y.toFixed(2), camera.position.z.toFixed(2));
                    
                    raycaster.setFromCamera(mouse, camera);
                    
                    // Set raycaster parameters for better gizmo detection
                    raycaster.params.Mesh.threshold = 0.1;
                    raycaster.far = 1000;
                    raycaster.near = 0.1;
                    
                    console.log('🎯 Raycaster ray origin:', raycaster.ray.origin.x.toFixed(2), raycaster.ray.origin.y.toFixed(2), raycaster.ray.origin.z.toFixed(2));
                    console.log('🎯 Raycaster ray direction:', raycaster.ray.direction.x.toFixed(3), raycaster.ray.direction.y.toFixed(3), raycaster.ray.direction.z.toFixed(3));
                    
                    raycaster.setFromCamera(mouse, camera);
                    
                    // Get all gizmo children and ensure they're clickable
                    const gizmoObjects = [];
                    rotationGizmo.traverse((child) => {
                        if (child.isMesh && child.userData.axis) {
                            gizmoObjects.push(child);
                        }
                    });
                    
                    console.log('🎯 Gizmo clickable objects:', gizmoObjects.length);
                    gizmoObjects.forEach((obj, index) => {
                        console.log(`🎯   Object ${index}: axis=${obj.userData.axis}, position=${obj.position.x.toFixed(2)}, ${obj.position.y.toFixed(2)}, ${obj.position.z.toFixed(2)}`);
                    });
                    
                    const gizmoIntersects = raycaster.intersectObjects(gizmoObjects, false);
                    
                    console.log('🎯 Gizmo intersects found:', gizmoIntersects.length);
                    if (gizmoIntersects.length > 0) {
                        console.log('🎯 Intersected object:', gizmoIntersects[0].object.userData);
                        console.log('🎯 Intersection point:', gizmoIntersects[0].point);
                        console.log('🎯 Distance:', gizmoIntersects[0].distance);
                    }
                    
                    if (gizmoIntersects.length > 0) {
                        // Clicked on gizmo axis
                        rotationAxis = gizmoIntersects[0].object.userData.axis;
                        console.log('🎯 GIZMO CLICKED! Axis:', rotationAxis);
                        highlightGizmoAxis(rotationAxis);
                        isDrawing = true;
                        
                        // Disable orbit controls during rotation
                        controls.enabled = false;
                        
                        // Store initial state for quaternion rotation
                        if (selectedModel) {
                            initialQuaternion = selectedModel.quaternion.clone();
                            
                            // Calculate initial angle from gizmo center to mouse position
                            const gizmoScreenPos = new THREE.Vector3();
                            gizmoScreenPos.copy(rotationGizmo.position);
                            gizmoScreenPos.project(camera);
                            
                            // Convert to screen coordinates for initial angle calculation
                            const rect = renderer.domElement.getBoundingClientRect();
                            const gizmoScreenX = ((gizmoScreenPos.x + 1) / 2) * rect.width;
                            const gizmoScreenY = ((-gizmoScreenPos.y + 1) / 2) * rect.height;
                            const mouseScreenX = event.clientX - rect.left;
                            const mouseScreenY = event.clientY - rect.top;
                            
                            previousAngle = Math.atan2(
                                mouseScreenY - gizmoScreenY,
                                mouseScreenX - gizmoScreenX
                            );
                            
                            console.log('🎯 Initial angle set:', previousAngle);
                        }
                        
                        mouse.lastX = event.clientX;
                        mouse.lastY = event.clientY;
                        saveUndoState();
                        console.log('🎯 Rotation axis selected:', rotationAxis);
                        return;
                    } else {
                        console.log('🎯 No gizmo intersection found');
                    }
                }
                
                // Check if we're clicking on an STL model
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(loadedModels);
                
                if (intersects.length > 0) {
                    const clickedModel = intersects[0].object;
                    console.log('📦 Model clicked:', clickedModel.userData.filename);
                    
                    if (activeTool === 'select') {
                        // Select the clicked model
                        selectModel(clickedModel);
                        return;
                    } else if (activeTool === 'rotate') {
                        // Only rotate if we have a selected model and it's the clicked one
                        if (!selectedModel) {
                            selectModel(clickedModel);
                            return;
                        }
                        if (clickedModel !== selectedModel) {
                            selectModel(clickedModel);
                            return;
                        }
                        // If no gizmo axis selected, allow free rotation
                        if (!rotationAxis) {
                            console.log('🎯 Starting free rotation on model');
                            isDrawing = true;
                            mouse.lastX = event.clientX;
                            mouse.lastY = event.clientY;
                            
                            // Store initial quaternion for free rotation
                            initialQuaternion = selectedModel.quaternion.clone();
                            rotationAxis = 'free';
                            highlightGizmoAxis('free');
                            
                            saveUndoState();
                        }
                        return;
                    }
                    
                    // For other tools, continue with existing logic
                    isDrawing = true;
                    
                    if (activeTool === 'cut') {
                        // Start lasso drawing
                        startLasso(event.clientX - rect.left, event.clientY - rect.top);
                    } else {
                        // Save undo state for material tools
                        saveUndoState();
                    }
                }
            }
        }

        function onMouseMove(event) {
            event.preventDefault();
            
            const rect = renderer.domElement.getBoundingClientRect();
            const screenX = event.clientX - rect.left;
            const screenY = event.clientY - rect.top;
            
            mouse.x = (screenX / rect.width) * 2 - 1;
            mouse.y = -(screenY / rect.height) * 2 + 1;
            
            // Handle gizmo hover highlighting when rotate tool is active but not drawing
            if (activeTool === 'rotate' && rotationGizmo && !isDrawing) {
                raycaster.setFromCamera(mouse, camera);
                
                // Get all gizmo children and ensure they're hoverable
                const gizmoObjects = [];
                rotationGizmo.traverse((child) => {
                    if (child.isMesh && child.userData.axis) {
                        gizmoObjects.push(child);
                    }
                });
                
                const gizmoIntersects = raycaster.intersectObjects(gizmoObjects, false);
                
                if (gizmoIntersects.length > 0) {
                    const hoveredAxis = gizmoIntersects[0].object.userData.axis;
                    console.log('🎯 Hovering over axis:', hoveredAxis);
                    highlightGizmoAxis(hoveredAxis);
                    renderer.domElement.style.cursor = 'grab';
                } else {
                    highlightGizmoAxis(null);
                    renderer.domElement.style.cursor = 'default';
                }
            }
            
            // Change cursor when actively rotating
            if (isDrawing && activeTool === 'rotate' && rotationAxis) {
                renderer.domElement.style.cursor = 'grabbing';
            }
            
            if (!isDrawing) return;
            
            if (activeTool === 'cut') {
                // Continue lasso drawing
                updateLasso(screenX, screenY);
            } else if (activeTool === 'rotate' && selectedModel && rotationAxis) {
                // Apply quaternion-based rotation
                const deltaX = event.clientX - mouse.lastX;
                const deltaY = event.clientY - mouse.lastY;
                
                console.log('🔄 Rotating - Axis:', rotationAxis, 'Delta:', deltaX, deltaY);
                
                if (rotationAxis === 'free') {
                    // Free rotation using screen-space movement
                    const rotationSpeed = 0.01;
                    
                    // Create rotation quaternions for X and Y axes
                    const rotX = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), deltaY * rotationSpeed);
                    const rotY = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), deltaX * rotationSpeed);
                    
                    // Combine rotations
                    const combinedRotation = new THREE.Quaternion();
                    combinedRotation.multiplyQuaternions(rotY, rotX);
                    
                    // Apply to current quaternion
                    const newQuaternion = new THREE.Quaternion();
                    newQuaternion.multiplyQuaternions(combinedRotation, initialQuaternion);
                    selectedModel.quaternion.copy(newQuaternion);
                    
                    // Update initial quaternion for smooth continued rotation
                    initialQuaternion.copy(newQuaternion);
                    console.log('🔄 Free rotation applied');
                } else if (['x', 'y', 'z'].includes(rotationAxis)) {
                    // Constrained axis rotation using circular motion around the gizmo
                    const gizmoScreenPos = new THREE.Vector3();
                    gizmoScreenPos.copy(rotationGizmo.position);
                    gizmoScreenPos.project(camera);
                    
                    // Convert to screen coordinates
                    const rect = renderer.domElement.getBoundingClientRect();
                    const gizmoScreenX = ((gizmoScreenPos.x + 1) / 2) * rect.width;
                    const gizmoScreenY = ((-gizmoScreenPos.y + 1) / 2) * rect.height;
                    
                    // Calculate current angle from gizmo center to mouse position
                    const currentMouseX = event.clientX - rect.left;
                    const currentMouseY = event.clientY - rect.top;
                    
                    let currentAngle, deltaAngle;
                    
                    if (rotationAxis === 'x') {
                        // For X-axis rotation, use Y-Z plane (mouse Y and distance from center)
                        currentAngle = Math.atan2(currentMouseY - gizmoScreenY, currentMouseX - gizmoScreenX);
                        deltaAngle = currentAngle - previousAngle;
                    } else if (rotationAxis === 'y') {
                        // For Y-axis rotation, use X-Z plane (mouse X and distance from center)
                        currentAngle = Math.atan2(currentMouseY - gizmoScreenY, currentMouseX - gizmoScreenX);
                        deltaAngle = currentAngle - previousAngle;
                    } else if (rotationAxis === 'z') {
                        // For Z-axis rotation, use X-Y plane (circular motion)
                        currentAngle = Math.atan2(currentMouseY - gizmoScreenY, currentMouseX - gizmoScreenX);
                        deltaAngle = currentAngle - previousAngle;
                    }
                    
                    // Smooth out large jumps (when angle wraps around)
                    if (Math.abs(deltaAngle) > Math.PI) {
                        deltaAngle = deltaAngle > 0 ? deltaAngle - 2 * Math.PI : deltaAngle + 2 * Math.PI;
                    }
                    
                    // Apply sensitivity factor
                    deltaAngle *= 1.5; // Make rotation more responsive
                    
                    // Create rotation quaternion based on selected axis
                    const rotationQuaternion = new THREE.Quaternion();
                    
                    if (rotationAxis === 'x') {
                        rotationQuaternion.setFromAxisAngle(new THREE.Vector3(1, 0, 0), deltaAngle);
                    } else if (rotationAxis === 'y') {
                        rotationQuaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), deltaAngle);
                    } else if (rotationAxis === 'z') {
                        rotationQuaternion.setFromAxisAngle(new THREE.Vector3(0, 0, 1), deltaAngle);
                    }
                    
                    // Apply rotation using quaternion multiplication
                    const newQuaternion = new THREE.Quaternion();
                    newQuaternion.multiplyQuaternions(rotationQuaternion, initialQuaternion);
                    selectedModel.quaternion.copy(newQuaternion);
                    
                    // Update for next frame
                    initialQuaternion.copy(newQuaternion);
                    previousAngle = currentAngle;
                }
                
                mouse.lastX = event.clientX;
                mouse.lastY = event.clientY;
            } else {
                // Apply material tools
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(loadedModels);
                
                if (intersects.length > 0) {
                    applyMaterialTool(intersects[0]);
                }
            }
        }

        function onMouseUp(event) {
            if (event.button !== 0) return;
            
            if (isDrawing) {
                isDrawing = false;
                
                if (activeTool === 'cut') {
                    // Complete lasso and perform cut
                    completeLasso();
                } else if (activeTool === 'rotate') {
                    // Reset rotation state and re-enable orbit controls
                    rotationAxis = null;
                    initialQuaternion = null;
                    previousAngle = 0;
                    highlightGizmoAxis(null);
                    controls.enabled = true; // Re-enable orbit controls
                    console.log('🎯 Rotation completed with quaternions');
                }
            }
        }

        // Lasso drawing functions
        function startLasso(x, y) {
            lassoPoints = [{x, y}];
            currentLassoPath = `M ${x} ${y}`;
            document.getElementById('lassoPath').setAttribute('d', currentLassoPath);
            console.log('🎯 Started lasso drawing');
        }

        function updateLasso(x, y) {
            lassoPoints.push({x, y});
            currentLassoPath += ` L ${x} ${y}`;
            document.getElementById('lassoPath').setAttribute('d', currentLassoPath);
        }

        function completeLasso() {
            if (lassoPoints.length < 3) {
                clearLasso();
                return;
            }
            
            // Close the lasso path
            currentLassoPath += ' Z';
            document.getElementById('lassoPath').setAttribute('d', currentLassoPath);
            
            console.log('✂️ Completing cut operation with', lassoPoints.length, 'points');
            
            // Save undo state before cutting
            saveUndoState();
            
            // Perform cutting operation
            performCut();
            
            // Clear lasso after a short delay
            setTimeout(clearLasso, 500);
        }

        function clearLasso() {
            lassoPoints = [];
            currentLassoPath = '';
            document.getElementById('lassoPath').setAttribute('d', '');
        }

        // Cut operation
        function performCut() {
            if (loadedModels.length === 0 || lassoPoints.length < 3) return;
            
            loadedModels.forEach(model => {
                const geometry = model.geometry.clone();
                const positions = geometry.attributes.position.array;
                const faces = [];
                
                // Convert vertices to screen coordinates and check if they're inside the lasso
                for (let i = 0; i < positions.length; i += 9) { // Each face has 3 vertices * 3 coordinates
                    const v1 = new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]);
                    const v2 = new THREE.Vector3(positions[i + 3], positions[i + 4], positions[i + 5]);
                    const v3 = new THREE.Vector3(positions[i + 6], positions[i + 7], positions[i + 8]);
                    
                    // Transform to world coordinates
                    v1.applyMatrix4(model.matrixWorld);
                    v2.applyMatrix4(model.matrixWorld);
                    v3.applyMatrix4(model.matrixWorld);
                    
                    // Project to screen coordinates
                    const s1 = worldToScreen(v1);
                    const s2 = worldToScreen(v2);
                    const s3 = worldToScreen(v3);
                    
                    // Check if any vertex of the face is inside the lasso
                    const inside1 = isPointInPolygon(s1, lassoPoints);
                    const inside2 = isPointInPolygon(s2, lassoPoints);
                    const inside3 = isPointInPolygon(s3, lassoPoints);
                    
                    // If any vertex is inside the lasso, mark face for removal
                    if (inside1 || inside2 || inside3) {
                        // Skip this face (don't add to faces array)
                        continue;
                    } else {
                        // Keep this face
                        faces.push(
                            positions[i], positions[i + 1], positions[i + 2],
                            positions[i + 3], positions[i + 4], positions[i + 5],
                            positions[i + 6], positions[i + 7], positions[i + 8]
                        );
                    }
                }
                
                // Create new geometry with remaining faces
                if (faces.length > 0) {
                    const newGeometry = new THREE.BufferGeometry();
                    newGeometry.setAttribute('position', new THREE.Float32BufferAttribute(faces, 3));
                    newGeometry.computeVertexNormals();
                    
                    // Update the model's geometry
                    model.geometry.dispose(); // Clean up old geometry
                    model.geometry = newGeometry;
                    
                    console.log(`✂️ Cut completed. Faces remaining: ${faces.length / 9}`);
                } else {
                    console.log('⚠️ Cut would remove entire model, operation cancelled');
                }
            });
        }

        // Utility functions
        function worldToScreen(worldPos) {
            const vector = worldPos.clone();
            vector.project(camera);
            
            const rect = renderer.domElement.getBoundingClientRect();
            return {
                x: (vector.x + 1) * rect.width / 2,
                y: (-vector.y + 1) * rect.height / 2
            };
        }

        function isPointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                if (((polygon[i].y > point.y) !== (polygon[j].y > point.y)) &&
                    (point.x < (polygon[j].x - polygon[i].x) * (point.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        // Material tools
        function applyMaterialTool(intersection) {
            const point = intersection.point;
            const model = intersection.object;
            const geometry = model.geometry;
            const positions = geometry.attributes.position.array;
            
            const radius = toolSettings.influenceSize; // Use configurable influence size
            let verticesToSmooth = []; // For smoothing operation
            
            // Create color attribute array if it doesn't exist
            if (!geometry.attributes.color) {
                const colors = new Float32Array(positions.length); // Same length as positions (3 values per vertex)
                // Initialize with default yellowish stone color (0xd4c299)
                for (let i = 0; i < colors.length; i += 3) {
                    colors[i] = 0.831;     // R component (212/255)
                    colors[i + 1] = 0.761; // G component (194/255)  
                    colors[i + 2] = 0.6;   // B component (153/255)
                }
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                // Update material to use vertex colors
                model.material = new THREE.MeshPhongMaterial({
                    vertexColors: true,
                    specular: 0x444444,
                    shininess: 30,
                    side: THREE.DoubleSide
                });
            }
            
            const colors = geometry.attributes.color.array;
            
            // Determine tool color
            let toolColor = { r: 0.831, g: 0.761, b: 0.6 }; // Default yellowish stone
            switch (activeTool) {
                case 'addMaterial':
                    toolColor = { r: 1.0, g: 0.4, b: 0.0 }; // Orange for adding material
                    break;
                case 'removeMaterial':
                    toolColor = { r: 0.0, g: 0.4, b: 1.0 }; // Blue for removing material
                    break;
                case 'smooth':
                    toolColor = { r: 0.4, g: 1.0, b: 0.4 }; // Green for smoothing
                    break;
            }
            
            // Apply tool effect to nearby vertices
            for (let i = 0; i < positions.length; i += 3) {
                const vertex = new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]);
                const worldVertex = vertex.clone().applyMatrix4(model.matrixWorld);
                
                const distance = worldVertex.distanceTo(point);
                
                if (distance <= radius) {
                    const falloff = Math.max(0, 1 - (distance / radius));
                    let displacement = 0;
                    
                    switch (activeTool) {
                        case 'addMaterial':
                            displacement = toolSettings.strength * falloff * 0.3;
                            break;
                        case 'removeMaterial':
                            displacement = -toolSettings.strength * falloff * 0.3;
                            break;
                        case 'smooth':
                            // Proper smoothing - don't add displacement, we'll smooth positions directly
                            displacement = 0;
                            break;
                    }
                    
                    if (displacement !== 0) {
                        // Get face normal for proper displacement direction
                        const normal = intersection.face.normal.clone();
                        positions[i] += normal.x * displacement;
                        positions[i + 1] += normal.y * displacement;
                        positions[i + 2] += normal.z * displacement;
                        
                        // Apply color to modified vertices with falloff
                        const colorIndex = i; // Color array has same indexing as position
                        const blendFactor = falloff * 0.8; // How much of the tool color to apply
                        
                        // Blend tool color with existing color
                        colors[colorIndex] = colors[colorIndex] * (1 - blendFactor) + toolColor.r * blendFactor;
                        colors[colorIndex + 1] = colors[colorIndex + 1] * (1 - blendFactor) + toolColor.g * blendFactor;
                        colors[colorIndex + 2] = colors[colorIndex + 2] * (1 - blendFactor) + toolColor.b * blendFactor;
                    } else if (activeTool === 'smooth' && distance <= radius) {
                        // Store vertices that need smoothing for later processing
                        verticesToSmooth.push({
                            index: i,
                            falloff: falloff,
                            originalPos: new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2])
                        });
                        
                        // Apply color to smoothed vertices
                        const colorIndex = i;
                        const blendFactor = falloff * 0.8;
                        colors[colorIndex] = colors[colorIndex] * (1 - blendFactor) + toolColor.r * blendFactor;
                        colors[colorIndex + 1] = colors[colorIndex + 1] * (1 - blendFactor) + toolColor.g * blendFactor;
                        colors[colorIndex + 2] = colors[colorIndex + 2] * (1 - blendFactor) + toolColor.b * blendFactor;
                    }
                }
            }
            
            // Handle smoothing separately after collecting all vertices to smooth
            if (activeTool === 'smooth' && verticesToSmooth.length > 0) {
                // Apply Laplacian smoothing
                verticesToSmooth.forEach(vertexInfo => {
                    const currentIndex = vertexInfo.index;
                    const falloff = vertexInfo.falloff;
                    
                    // Find neighboring vertices within a small radius
                    const currentPos = new THREE.Vector3(positions[currentIndex], positions[currentIndex + 1], positions[currentIndex + 2]);
                    const neighbors = [];
                    const neighborRadius = toolSettings.influenceSize * 0.3; // Smaller radius for neighbor detection
                    
                    for (let j = 0; j < positions.length; j += 3) {
                        if (j === currentIndex) continue; // Skip self
                        
                        const neighborPos = new THREE.Vector3(positions[j], positions[j + 1], positions[j + 2]);
                        const distance = currentPos.distanceTo(neighborPos);
                        
                        if (distance <= neighborRadius) {
                            neighbors.push(neighborPos);
                        }
                    }
                    
                    if (neighbors.length > 0) {
                        // Calculate average position of neighbors
                        const avgPos = new THREE.Vector3(0, 0, 0);
                        neighbors.forEach(neighbor => {
                            avgPos.add(neighbor);
                        });
                        avgPos.divideScalar(neighbors.length);
                        
                        // Smooth by blending current position with average of neighbors
                        const smoothingFactor = toolSettings.strength * falloff * 0.5;
                        
                        positions[currentIndex] = positions[currentIndex] * (1 - smoothingFactor) + avgPos.x * smoothingFactor;
                        positions[currentIndex + 1] = positions[currentIndex + 1] * (1 - smoothingFactor) + avgPos.y * smoothingFactor;
                        positions[currentIndex + 2] = positions[currentIndex + 2] * (1 - smoothingFactor) + avgPos.z * smoothingFactor;
                    }
                });
            }
            
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            geometry.computeVertexNormals();
        }

        // Make printable function - add dental base and thicken walls inward for 3D printing
        function makePrintable(thicknessInMm = 2.0) {
            if (!selectedModel) {
                alert('Please select a model first');
                return;
            }
            
            console.log('🖨️ Creating professional dental base with support posts and curved platform');
            
            // Save undo state
            saveUndoState();
            
            const originalGeometry = selectedModel.geometry;
            const positions = originalGeometry.attributes.position.array;
            const normals = originalGeometry.attributes.normal.array;
            
            // Find the bounding box to create a proper base
            originalGeometry.computeBoundingBox();
            const bbox = originalGeometry.boundingBox;
            
            // Create inner surface by offsetting vertices inward
            const innerPositions = new Float32Array(positions.length);
            
            for (let i = 0; i < positions.length; i += 3) {
                // Get vertex position
                const x = positions[i];
                const y = positions[i + 1];
                const z = positions[i + 2];
                
                // Get vertex normal (invert for inward direction)
                const nx = -normals[i];
                const ny = -normals[i + 1];  
                const nz = -normals[i + 2];
                
                // Offset vertex inward along inverted normal
                innerPositions[i] = x + (nx * thicknessInMm);
                innerPositions[i + 1] = y + (ny * thicknessInMm);
                innerPositions[i + 2] = z + (nz * thicknessInMm);
            }
            
            // Professional dental base parameters
            const baseY = bbox.min.y - 8; // Base positioned lower for better support
            const baseThickness = 4.0; // Thicker base for stability
            const platformHeight = 3.0; // Raised platform height
            const archWidth = (bbox.max.x - bbox.min.x);
            const archDepth = (bbox.max.z - bbox.min.z);
            const baseCenterX = (bbox.max.x + bbox.min.x) / 2;
            const baseCenterZ = (bbox.max.z + bbox.min.z) / 2;
            
            // Create curved dental platform (follows arch shape)
            const platformVertices = [];
            const platformRadius = Math.max(archWidth, archDepth) * 0.6;
            const platformSegments = 32;
            
            for (let i = 0; i < platformSegments; i++) {
                const angle1 = (i / platformSegments) * Math.PI * 2;
                const angle2 = ((i + 1) / platformSegments) * Math.PI * 2;
                
                const x1 = baseCenterX + Math.cos(angle1) * platformRadius;
                const z1 = baseCenterZ + Math.sin(angle1) * platformRadius;
                const x2 = baseCenterX + Math.cos(angle2) * platformRadius;
                const z2 = baseCenterZ + Math.sin(angle2) * platformRadius;
                
                // Top surface of curved platform
                platformVertices.push(
                    baseCenterX, bbox.min.y - 1, baseCenterZ,
                    x1, bbox.min.y - 1, z1,
                    x2, bbox.min.y - 1, z2
                );
                
                // Side walls of platform
                platformVertices.push(
                    x1, bbox.min.y - 1, z1,
                    x1, bbox.min.y - 1 - platformHeight, z1,
                    x2, bbox.min.y - 1 - platformHeight, z2,
                    
                    x1, bbox.min.y - 1, z1,
                    x2, bbox.min.y - 1 - platformHeight, z2,
                    x2, bbox.min.y - 1, z2
                );
            }
            
            // Create support posts (like in your reference images)
            const postVertices = [];
            const postRadius = 1.5; // Post radius
            const postHeight = 8.0; // Post height
            const postSegments = 12;
            
            // Position support posts around the dental arch
            const postPositions = [
                { x: baseCenterX - archWidth * 0.4, z: baseCenterZ - archDepth * 0.3 },
                { x: baseCenterX + archWidth * 0.4, z: baseCenterZ - archDepth * 0.3 },
                { x: baseCenterX - archWidth * 0.4, z: baseCenterZ + archDepth * 0.3 },
                { x: baseCenterX + archWidth * 0.4, z: baseCenterZ + archDepth * 0.3 },
                { x: baseCenterX, z: baseCenterZ - archDepth * 0.5 },
                { x: baseCenterX, z: baseCenterZ + archDepth * 0.5 }
            ];
            
            postPositions.forEach(pos => {
                // Create cylindrical support post
                for (let i = 0; i < postSegments; i++) {
                    const angle1 = (i / postSegments) * Math.PI * 2;
                    const angle2 = ((i + 1) / postSegments) * Math.PI * 2;
                    
                    const x1 = pos.x + Math.cos(angle1) * postRadius;
                    const z1 = pos.z + Math.sin(angle1) * postRadius;
                    const x2 = pos.x + Math.cos(angle2) * postRadius;
                    const z2 = pos.z + Math.sin(angle2) * postRadius;
                    
                    // Post cylinder walls
                    postVertices.push(
                        x1, bbox.min.y - 1 - platformHeight, z1,
                        x1, baseY, z1,
                        x2, baseY, z2,
                        
                        x1, bbox.min.y - 1 - platformHeight, z1,
                        x2, baseY, z2,
                        x2, bbox.min.y - 1 - platformHeight, z2
                    );
                }
                
                // Post top cap (connecting to platform)
                for (let i = 0; i < postSegments; i++) {
                    const angle1 = (i / postSegments) * Math.PI * 2;
                    const angle2 = ((i + 1) / postSegments) * Math.PI * 2;
                    
                    const x1 = pos.x + Math.cos(angle1) * postRadius;
                    const z1 = pos.z + Math.sin(angle1) * postRadius;
                    const x2 = pos.x + Math.cos(angle2) * postRadius;
                    const z2 = pos.z + Math.sin(angle2) * postRadius;
                    
                    postVertices.push(
                        pos.x, bbox.min.y - 1 - platformHeight, pos.z,
                        x1, bbox.min.y - 1 - platformHeight, z1,
                        x2, bbox.min.y - 1 - platformHeight, z2
                    );
                }
                
                // Post bottom cap (on base)
                for (let i = 0; i < postSegments; i++) {
                    const angle1 = (i / postSegments) * Math.PI * 2;
                    const angle2 = ((i + 1) / postSegments) * Math.PI * 2;
                    
                    const x1 = pos.x + Math.cos(angle1) * postRadius;
                    const z1 = pos.z + Math.sin(angle1) * postRadius;
                    const x2 = pos.x + Math.cos(angle2) * postRadius;
                    const z2 = pos.z + Math.sin(angle2) * postRadius;
                    
                    postVertices.push(
                        pos.x, baseY, pos.z,
                        x2, baseY, z2,
                        x1, baseY, z1
                    );
                }
            });
            
            // Create main base platform
            const baseVertices = [];
            const baseWidth = archWidth + 20; // Extended base for stability
            const baseDepth = archDepth + 20;
            
            const baseCorners = [
                [baseCenterX - baseWidth/2, baseY, baseCenterZ - baseDepth/2],
                [baseCenterX + baseWidth/2, baseY, baseCenterZ - baseDepth/2],
                [baseCenterX + baseWidth/2, baseY, baseCenterZ + baseDepth/2],
                [baseCenterX - baseWidth/2, baseY, baseCenterZ + baseDepth/2],
                [baseCenterX - baseWidth/2, baseY - baseThickness, baseCenterZ - baseDepth/2],
                [baseCenterX + baseWidth/2, baseY - baseThickness, baseCenterZ - baseDepth/2],
                [baseCenterX + baseWidth/2, baseY - baseThickness, baseCenterZ + baseDepth/2],
                [baseCenterX - baseWidth/2, baseY - baseThickness, baseCenterZ + baseDepth/2]
            ];
            
            // Top face
            baseVertices.push(
                ...baseCorners[0], ...baseCorners[1], ...baseCorners[2],
                ...baseCorners[0], ...baseCorners[2], ...baseCorners[3]
            );
            
            // Bottom face
            baseVertices.push(
                ...baseCorners[4], ...baseCorners[6], ...baseCorners[5],
                ...baseCorners[4], ...baseCorners[7], ...baseCorners[6]
            );
            
            // Side faces
            const sides = [
                [0, 5, 1, 0, 4, 5], // Front
                [1, 6, 2, 1, 5, 6], // Right
                [2, 7, 3, 2, 6, 7], // Back
                [3, 4, 0, 3, 7, 4]  // Left
            ];
            
            sides.forEach(side => {
                baseVertices.push(
                    ...baseCorners[side[0]], ...baseCorners[side[1]], ...baseCorners[side[2]],
                    ...baseCorners[side[3]], ...baseCorners[side[4]], ...baseCorners[side[5]]
                );
            });
            
            // Combine all surfaces
            const combinedVertices = [];
            
            // Add outer surface (original dental arch)
            for (let i = 0; i < positions.length; i += 9) {
                combinedVertices.push(
                    positions[i], positions[i + 1], positions[i + 2],
                    positions[i + 3], positions[i + 4], positions[i + 5],
                    positions[i + 6], positions[i + 7], positions[i + 8]
                );
            }
            
            // Add inner surface (for wall thickness)
            for (let i = 0; i < innerPositions.length; i += 9) {
                combinedVertices.push(
                    innerPositions[i + 6], innerPositions[i + 7], innerPositions[i + 8],
                    innerPositions[i + 3], innerPositions[i + 4], innerPositions[i + 5],
                    innerPositions[i], innerPositions[i + 1], innerPositions[i + 2]
                );
            }
            
            // Add connecting walls between outer and inner surfaces
            const bottomVertices = [];
            for (let i = 0; i < positions.length; i += 3) {
                const y = positions[i + 1];
                if (y <= bbox.min.y + 1) { // Near the bottom of the arch
                    const outerX = positions[i];
                    const outerY = positions[i + 1];
                    const outerZ = positions[i + 2];
                    const innerX = innerPositions[i];
                    const innerY = innerPositions[i + 1];
                    const innerZ = innerPositions[i + 2];
                    
                    bottomVertices.push(
                        outerX, bbox.min.y - 1, outerZ,
                        innerX, bbox.min.y - 1, innerZ,
                        outerX, outerY, outerZ,
                        
                        innerX, bbox.min.y - 1, innerZ,
                        innerX, innerY, innerZ,
                        outerX, outerY, outerZ
                    );
                }
            }
            
            // Add all components
            combinedVertices.push(...baseVertices);          // Main base platform
            combinedVertices.push(...platformVertices);      // Curved dental platform
            combinedVertices.push(...postVertices);          // Support posts
            combinedVertices.push(...bottomVertices);        // Connecting walls
            
            // Create new geometry with professional dental base
            const newGeometry = new THREE.BufferGeometry();
            newGeometry.setAttribute('position', new THREE.Float32BufferAttribute(combinedVertices, 3));
            newGeometry.computeVertexNormals();
            newGeometry.computeBoundingBox();
            
            // Update the model's geometry
            originalGeometry.dispose();
            selectedModel.geometry = newGeometry;
            
            // Update filename to indicate it's printable
            if (selectedModel.userData.filename) {
                selectedModel.userData.filename = selectedModel.userData.filename.replace('.stl', '_professional_dental_base.stl');
                selectTool(activeTool); // Refresh status display
            }
            
            console.log('✅ Professional dental base created with curved platform and support posts');
        }

        // STL Export functionality
        function exportSTL(model = null) {
            const modelToExport = model || selectedModel;
            
            if (!modelToExport) {
                alert('Please select a model to export');
                return;
            }
            
            console.log('💾 Exporting STL for:', modelToExport.userData.filename || 'model');
            
            // Get the geometry from the model
            const geometry = modelToExport.geometry;
            const positions = geometry.attributes.position.array;
            
            // Create STL content (ASCII format for better compatibility)
            let stlContent = `solid ${modelToExport.userData.filename || 'exported_model'}\n`;
            
            // Process each triangle (3 vertices per face)
            for (let i = 0; i < positions.length; i += 9) {
                // Get vertices of the triangle
                const v1 = new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]);
                const v2 = new THREE.Vector3(positions[i + 3], positions[i + 4], positions[i + 5]);
                const v3 = new THREE.Vector3(positions[i + 6], positions[i + 7], positions[i + 8]);
                
                // Apply model transformations (rotation, scale, position)
                v1.applyMatrix4(modelToExport.matrixWorld);
                v2.applyMatrix4(modelToExport.matrixWorld);
                v3.applyMatrix4(modelToExport.matrixWorld);
                
                // Calculate face normal
                const normal = new THREE.Vector3();
                const edge1 = new THREE.Vector3().subVectors(v2, v1);
                const edge2 = new THREE.Vector3().subVectors(v3, v1);
                normal.crossVectors(edge1, edge2).normalize();
                
                // Write triangle to STL format
                stlContent += `  facet normal ${normal.x.toExponential(6)} ${normal.y.toExponential(6)} ${normal.z.toExponential(6)}\n`;
                stlContent += `    outer loop\n`;
                stlContent += `      vertex ${v1.x.toExponential(6)} ${v1.y.toExponential(6)} ${v1.z.toExponential(6)}\n`;
                stlContent += `      vertex ${v2.x.toExponential(6)} ${v2.y.toExponential(6)} ${v2.z.toExponential(6)}\n`;
                stlContent += `      vertex ${v3.x.toExponential(6)} ${v3.y.toExponential(6)} ${v3.z.toExponential(6)}\n`;
                stlContent += `    endloop\n`;
                stlContent += `  endfacet\n`;
            }
            
            stlContent += `endsolid ${modelToExport.userData.filename || 'exported_model'}\n`;
            
            // Create and download the file
            const blob = new Blob([stlContent], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            
            // Create download link
            const link = document.createElement('a');
            link.href = url;
            
            // Generate filename
            let filename = modelToExport.userData.filename || 'exported_model.stl';
            if (!filename.toLowerCase().endsWith('.stl')) {
                filename += '.stl';
            }
            
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Clean up
            URL.revokeObjectURL(url);
            
            console.log('✅ STL exported successfully:', filename);
        }
        
        // Export all models as separate STL files
        function exportAllSTL() {
            if (loadedModels.length === 0) {
                alert('No models to export');
                return;
            }
            
            console.log('💾 Exporting all models as STL files...');
            
            loadedModels.forEach((model, index) => {
                // Add a small delay between exports to avoid browser issues
                setTimeout(() => {
                    exportSTL(model);
                }, index * 100);
            });
        }
        
        // Enhanced export with options
        function showExportDialog() {
            if (loadedModels.length === 0) {
                alert('No models to export');
                return;
            }
            
            // Create export dialog
            const dialog = document.createElement('div');
            dialog.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            dialog.innerHTML = `
                <div class="bg-gray-800 rounded-lg p-6 max-w-md w-full mx-4">
                    <h3 class="text-lg font-semibold text-white mb-4">Export STL</h3>
                    
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm text-gray-300 mb-2">Export Option:</label>
                            <div class="space-y-2">
                                <label class="flex items-center text-white">
                                    <input type="radio" name="exportType" value="selected" class="mr-2" ${selectedModel ? 'checked' : 'disabled'}>
                                    Export Selected Model ${selectedModel ? `(${selectedModel.userData.filename || 'Unnamed'})` : '(None selected)'}
                                </label>
                                <label class="flex items-center text-white">
                                    <input type="radio" name="exportType" value="all" class="mr-2" ${!selectedModel ? 'checked' : ''}>
                                    Export All Models (${loadedModels.length} files)
                                </label>
                            </div>
                        </div>
                        
                        <div>
                            <label class="block text-sm text-gray-300 mb-2">File Format:</label>
                            <select class="w-full bg-gray-700 text-white rounded px-3 py-2" id="exportFormat">
                                <option value="ascii">STL ASCII (Compatible)</option>
                                <option value="binary">STL Binary (Compact)</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="flex justify-end space-x-3 mt-6">
                        <button class="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700" onclick="this.closest('.fixed').remove()">
                            Cancel
                        </button>
                        <button class="px-4 py-2 bg-dental-primary text-white rounded hover:bg-orange-600" onclick="performExport()">
                            Export
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(dialog);
            
            // Add export function to window for onclick access
            window.performExport = function() {
                const exportType = document.querySelector('input[name="exportType"]:checked').value;
                const format = document.getElementById('exportFormat').value;
                
                if (exportType === 'selected') {
                    exportSTL(selectedModel);
                } else {
                    exportAllSTL();
                }
                
                dialog.remove();
                delete window.performExport; // Clean up
            };
        }

        // STL Loading
        function loadSTL(file) {
            console.log('🚀 Starting STL load for:', file.name);
            
            if (!THREE.STLLoader) {
                console.error('❌ STLLoader not available. Loaders may not have loaded yet.');
                setTimeout(() => loadSTL(file), 1000); // Retry after 1 second
                return;
            }
            
            const loader = new THREE.STLLoader();
            const reader = new FileReader();
            
            reader.onload = function(event) {
                console.log('📖 File read complete, parsing STL...');
                try {
                    const geometry = loader.parse(event.target.result);
                    console.log('✅ STL parsed successfully, vertices:', geometry.attributes.position.count);
                    
                    // Center geometry
                    geometry.computeBoundingBox();
                    const center = new THREE.Vector3();
                    geometry.boundingBox.getCenter(center);
                    geometry.translate(-center.x, -center.y, -center.z);
                    
                    const material = new THREE.MeshPhongMaterial({
                        color: 0xd4c299, // More yellowish stone color
                        specular: 0x444444,
                        shininess: 30,
                        side: THREE.DoubleSide
                    });

                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    
                    // Store filename for reference
                    mesh.userData.filename = file.name;
                    mesh.userData.visible = true;
                    
                    console.log('🎯 Adding mesh to scene');
                    scene.add(mesh);
                    loadedModels.push(mesh);

                    // Apply current viewport mode to new mesh
                    setTimeout(() => setViewportMode(currentViewportMode), 100);

                    // Auto-select first model
                    if (loadedModels.length === 1) {
                        selectModel(mesh);
                        console.log('🎯 Auto-selected first model');
                    }

                    // Update camera to fit model
                    fitCameraToObject(camera, controls, mesh, 1.5);
                    
                    // Add to file list with visibility toggle
                    console.log('📋 Adding to file list');
                    addToFileList(file.name, mesh);
                    
                    console.log('✅ STL loaded successfully:', file.name);
                } catch (error) {
                    console.error('❌ Error parsing STL:', error);
                    alert('Error loading STL file: ' + error.message);
                }
            };
            
            reader.onerror = function(error) {
                console.error('❌ Error reading file:', error);
                alert('Error reading file: ' + file.name);
            };
            
            console.log('📖 Starting file read...');
            reader.readAsArrayBuffer(file);
        }

        // Fit camera to object
        function fitCameraToObject(camera, controls, object, offset) {
            const boundingBox = new THREE.Box3();
            boundingBox.setFromObject(object);

            const center = new THREE.Vector3();
            boundingBox.getCenter(center);

            const size = boundingBox.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / Math.sin(fov / 2)) * offset;

            camera.position.set(0, 0, cameraZ);
            controls.target.copy(center);
            controls.update();
        }

        function addToFileList(filename, model) {
            const fileList = document.getElementById('uploadedFilesList');
            const noFilesMessage = document.getElementById('noFilesMessage');
            
            // Hide "no files" message when first file is added
            if (noFilesMessage) {
                noFilesMessage.style.display = 'none';
            }
            
            const fileElement = document.createElement('div');
            fileElement.className = 'flex items-center space-x-2 p-2 bg-gray-800 rounded text-sm';
            fileElement.innerHTML = `
                <i class="fas fa-file text-dental-primary"></i>
                <span class="truncate flex-1">${filename}</span>
                <button class="select-model-btn text-gray-400 hover:text-dental-primary cursor-pointer" title="Select Model">
                    <i class="fas fa-mouse-pointer"></i>
                </button>
                <button class="toggle-visibility-btn text-dental-primary hover:text-gray-400 cursor-pointer" title="Toggle Visibility">
                    <i class="fas fa-eye"></i>
                </button>
            `;
            
            // Add event listeners
            const selectBtn = fileElement.querySelector('.select-model-btn');
            selectBtn.addEventListener('click', () => {
                selectModel(model);
                selectTool('select');
            });
            
            const visibilityBtn = fileElement.querySelector('.toggle-visibility-btn');
            visibilityBtn.addEventListener('click', () => {
                toggleModelVisibility(model);
                const icon = visibilityBtn.querySelector('i');
                if (model.visible) {
                    icon.className = 'fas fa-eye';
                    visibilityBtn.className = 'toggle-visibility-btn text-dental-primary hover:text-gray-400 cursor-pointer';
                } else {
                    icon.className = 'fas fa-eye-slash';
                    visibilityBtn.className = 'toggle-visibility-btn text-gray-400 hover:text-dental-primary cursor-pointer';
                }
            });
            
            fileList.appendChild(fileElement);
        }

        // Update the file list to reflect current models (useful after model modifications)
        function updateFileList() {
            const fileList = document.getElementById('uploadedFilesList');
            const noFilesMessage = document.getElementById('noFilesMessage');
            
            // Clear current file list
            fileList.innerHTML = '';
            
            if (loadedModels.length === 0) {
                // Show "no files" message if no models are loaded
                const noFilesDiv = document.createElement('div');
                noFilesDiv.className = 'text-gray-500 text-sm italic';
                noFilesDiv.id = 'noFilesMessage';
                noFilesDiv.textContent = 'No files uploaded yet';
                fileList.appendChild(noFilesDiv);
            } else {
                // Re-add all current models to the file list
                loadedModels.forEach(model => {
                    const filename = model.userData.filename || 'Unknown File';
                    addToFileList(filename, model);
                });
            }
            
            console.log('🔄 File list updated with', loadedModels.length, 'models');
        }

        // Undo system
        function saveUndoState() {
            if (loadedModels.length === 0) return;
            
            const undoState = loadedModels.map(model => ({
                positions: new Float32Array(model.geometry.attributes.position.array),
                colors: model.geometry.attributes.color ? new Float32Array(model.geometry.attributes.color.array) : null,
                geometry: model.geometry.clone(),
                material: model.material.clone() // Also save material state
            }));
            
            undoStack.push(undoState);
            
            if (undoStack.length > maxUndoSteps) {
                undoStack.shift();
            }
            
            updateUndoButton();
        }

        function performUndo() {
            if (undoStack.length === 0) return;
            
            const undoState = undoStack.pop();
            
            loadedModels.forEach((model, index) => {
                if (undoState[index]) {
                    // Dispose old geometry
                    model.geometry.dispose();
                    
                    // Restore geometry
                    model.geometry = undoState[index].geometry.clone();
                    
                    // Restore colors if they existed
                    if (undoState[index].colors) {
                        const colors = new Float32Array(undoState[index].colors);
                        model.geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                        
                        // Ensure material uses vertex colors
                        if (!model.material.vertexColors) {
                            model.material = new THREE.MeshPhongMaterial({
                                vertexColors: true,
                                specular: 0x444444,
                                shininess: 30,
                                side: THREE.DoubleSide
                            });
                        }
                    } else {
                        // No colors saved, restore original material
                        model.material = new THREE.MeshPhongMaterial({
                            color: 0xd4c299, // More yellowish stone color
                            specular: 0x444444,
                            shininess: 30,
                            side: THREE.DoubleSide
                        });
                    }
                }
            });
            
            updateUndoButton();
            console.log('↶ Undo performed with color restoration');
        }

        function updateUndoButton() {
            const undoButton = document.getElementById('undoButton');
            if (undoButton) {
                undoButton.disabled = undoStack.length === 0;
                undoButton.style.opacity = undoStack.length === 0 ? '0.5' : '1';
            }
        }

        function clearAll() {
            loadedModels.forEach(model => {
                scene.remove(model);
                model.geometry.dispose();
                model.material.dispose();
            });
            loadedModels = [];
            selectedModel = null;
            undoStack = [];
            hideRotationGizmo(); // Hide gizmo when clearing
            updateUndoButton();
            
            // Clear the dynamic file list and show "no files" message
            const fileList = document.getElementById('uploadedFilesList');
            const noFilesMessage = document.getElementById('noFilesMessage');
            fileList.innerHTML = '<div class="text-gray-500 text-sm italic" id="noFilesMessage">No files uploaded yet</div>';
            
            console.log('🗑️ All models cleared');
        }

        // Initialize everything when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🎯 DOM loaded, initializing...');
            
            init3DViewer();
            
            // Initialize dental bases
            console.log('🦷 Initializing dental bases...');
            
            if (typeof DentalBases === 'undefined') {
                console.error('❌ DentalBases class not found. Check if dentalBases.js is loaded.');
                return;
            }
            
            if (typeof DentalBaseUI === 'undefined') {
                console.error('❌ DentalBaseUI class not found. Check if dentalBaseUI.js is loaded.');
                return;
            }
            
            const dentalBases = new DentalBases();
            const dentalBaseIntegrator = new DentalBaseIntegrator(dentalBases);
            const dentalBaseUI = new DentalBaseUI(dentalBases, dentalBaseIntegrator, scene, loadedModels, addToFileList);
            
            console.log('✅ Dental bases initialized successfully');
            
            // Preload the STL bases for better performance
            dentalBases.preloadBases().then(() => {
                console.log('✅ Dental base STL files preloaded');
            }).catch(error => {
                console.warn('⚠️ Some dental bases failed to preload:', error);
            });
            
            // Make dentalBaseUI available globally for button handler
            window.dentalBaseUI = dentalBaseUI;
            
            // Initialize advanced modeling tools
            console.log('🔧 Initializing advanced modeling tools with backend...');
            
            if (typeof ModelingToolsWithBackend === 'undefined') {
                console.error('❌ ModelingToolsWithBackend class not found. Check if modelingBackendService.js is loaded.');
                return;
            }
            
            // Initialize the modeling tools backend service
            const modelingTools = new ModelingToolsWithBackend();
            
            // Setup modeling tools event listeners
            setupModelingToolsEventListeners(modelingTools);
            
            // Make modeling tools available globally
            window.modelingTools = modelingTools;
            
            console.log('✅ Advanced modeling tools with backend initialized successfully');
            
            console.log('✅ Advanced modeling tools with backend initialized successfully');
            
            // Tool button handlers
            document.querySelectorAll('.tool-button[data-tool]').forEach(button => {
                button.addEventListener('click', function() {
                    selectTool(this.getAttribute('data-tool'));
                });
            });
            
            // File upload
            const dropzone = document.getElementById('dropzone');
            const fileInput = document.getElementById('fileInput');
            
            console.log('🔍 File upload elements:', { dropzone, fileInput });
            
            if (!dropzone) {
                console.error('❌ Dropzone element not found!');
                return;
            }
            
            if (!fileInput) {
                console.error('❌ File input element not found!');
                return;
            }
            
            // Drag and drop
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropzone.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            ['dragenter', 'dragover'].forEach(eventName => {
                dropzone.addEventListener(eventName, () => {
                    console.log('🎯 Drag enter/over detected');
                    dropzone.classList.add('active');
                }, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropzone.addEventListener(eventName, () => {
                    console.log('🎯 Drag leave/drop detected');
                    dropzone.classList.remove('active');
                }, false);
            });

            dropzone.addEventListener('drop', handleDrop, false);
            fileInput.addEventListener('change', handleFiles, false);
            dropzone.addEventListener('click', () => {
                console.log('🎯 Dropzone clicked, opening file picker');
                fileInput.click();
            });

            function handleDrop(e) {
                console.log('📁 Files dropped:', e.dataTransfer.files);
                const files = e.dataTransfer.files;
                handleFiles({ target: { files } });
            }

            function handleFiles(e) {
                console.log('📁 Handling files:', e.target.files);
                const files = e.target.files;
                Array.from(files).forEach(file => {
                    console.log('📄 Processing file:', file.name, file.type);
                    if (file.name.toLowerCase().endsWith('.stl')) {
                        console.log('✅ Loading STL file:', file.name);
                        loadSTL(file);
                    } else {
                        console.warn('⚠️ File is not an STL:', file.name);
                    }
                });
            }
            
            // Button handlers
            document.getElementById('undoButton').addEventListener('click', performUndo);
            document.getElementById('clearButton').addEventListener('click', clearAll);
            document.getElementById('makePrintableButton').addEventListener('click', () => makePrintable(2.0));
            document.getElementById('saveButton').addEventListener('click', showExportDialog);
            document.getElementById('dentalBaseButton').addEventListener('click', () => {
                console.log('🦷 Dental base button clicked');
                if (window.dentalBaseUI) {
                    window.dentalBaseUI.showBaseSelectionDialog(selectedModel);
                } else {
                    console.error('❌ dentalBaseUI not available');
                }
            });
            
            document.getElementById('orientationButton').addEventListener('click', () => {
                console.log('🧭 Orientation button clicked');
                if (window.modelingToolsUI) {
                    window.modelingToolsUI.showOrientationDialog(selectedModel);
                } else {
                    console.error('❌ modelingToolsUI not available');
                }
            });
            
            document.getElementById('solidifyButton').addEventListener('click', () => {
                console.log('🔧 Solidify button clicked');
                if (window.modelingToolsUI) {
                    window.modelingToolsUI.showSolidificationDialog(selectedModel);
                } else {
                    console.error('❌ modelingToolsUI not available');
                }
            });
            
            // Viewport control handlers
            document.querySelectorAll('.viewport-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const mode = this.getAttribute('data-mode');
                    setViewportMode(mode);
                });
            });
            
            // Bottom viewport controls
            document.getElementById('resetViewBtn').addEventListener('click', resetView);
            document.getElementById('zoomInBtn').addEventListener('click', zoomIn);
            document.getElementById('zoomOutBtn').addEventListener('click', zoomOut);
            document.getElementById('toggleGridBtn').addEventListener('click', toggleGrid);
            
            // Tool settings controls
            const strengthSlider = document.getElementById('strengthSlider');
            const strengthValue = document.getElementById('strengthValue');
            const influenceSizeSlider = document.getElementById('influenceSizeSlider');
            const influenceSizeValue = document.getElementById('influenceSizeValue');
            const showToolInfoCheckbox = document.getElementById('showToolInfo');
            const showGridCheckbox = document.getElementById('showGrid');
            
            strengthSlider.oninput = function() {
                toolSettings.strength = parseFloat(this.value);
                strengthValue.textContent = toolSettings.strength.toFixed(2);
            };
            
            influenceSizeSlider.oninput = function() {
                toolSettings.influenceSize = parseFloat(this.value);
                influenceSizeValue.textContent = toolSettings.influenceSize.toFixed(1);
                
                // Update tool status if using a material tool
                if (['addMaterial', 'removeMaterial', 'smooth'].includes(activeTool)) {
                    selectTool(activeTool); // Refresh the tool status display
                }
            };
            
            showToolInfoCheckbox.onchange = function() {
                toolSettings.showToolInfo = this.checked;
            };
            
            showGridCheckbox.onchange = function() {
                toolSettings.showGrid = this.checked;
                isGridVisible = this.checked;
                if (gridHelper) {
                    gridHelper.visible = this.checked;
                }
                
                // Update grid button state
                const gridBtn = document.getElementById('toggleGridBtn');
                if (gridBtn) {
                    if (this.checked) {
                        gridBtn.classList.add('bg-dental-primary', 'text-white');
                        gridBtn.classList.remove('bg-gray-700');
                    } else {
                        gridBtn.classList.remove('bg-dental-primary', 'text-white');
                        gridBtn.classList.add('bg-gray-700');
                    }
                }
                
                console.log('Grid visibility:', this.checked ? 'shown' : 'hidden');
            };
            
            // Tab switching (keeping existing functionality)
            const tabButtons = document.querySelectorAll('.tab-button');
            tabButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const tabName = this.textContent.trim();

                    // Update active tab button
                    tabButtons.forEach(btn => btn.classList.remove('active', 'bg-dental-primary', 'text-white'));
                    this.classList.add('active', 'bg-dental-primary', 'text-white');

                    // Update tab content
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.remove('active');
                    });

                    if (tabName === 'Design') {
                        document.querySelector('.tab-content:nth-child(1)').classList.add('active');
                    } else if (tabName === 'Materials') {
                        document.querySelector('.tab-content:nth-child(2)').classList.add('active');
                    } else if (tabName === 'Layers') {
                        document.querySelector('.tab-content:nth-child(3)').classList.add('active');
                    }
                });
            });

            // Color options (keeping existing functionality)
            const colorOptions = document.querySelectorAll('.color-option');
            colorOptions.forEach(option => {
                option.addEventListener('click', function() {
                    colorOptions.forEach(opt => opt.classList.remove('selected'));
                    this.classList.add('selected');
                });
            });

            // Material options (keeping existing functionality)
            const materialOptions = document.querySelectorAll('.material-option');
            materialOptions.forEach(option => {
                option.addEventListener('click', function() {
                    materialOptions.forEach(opt => opt.classList.remove('bg-dental-primary', 'text-white'));
                    this.classList.add('bg-dental-primary', 'text-white');
                });
            });
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.key === 'z') {
                    e.preventDefault();
                    performUndo();
                }
                
                if (e.ctrlKey && e.key === 's') {
                    e.preventDefault();
                    showExportDialog();
                }
                
                if (e.key >= '1' && e.key <= '7') {
                    const tools = ['select', 'addMaterial', 'removeMaterial', 'smooth', 'measure', 'cut', 'rotate'];
                    const toolIndex = parseInt(e.key) - 1;
                    if (toolIndex < tools.length) {
                        selectTool(tools[toolIndex]);
                        e.preventDefault();
                    }
                }
                
                if (e.key === '8') {
                    e.preventDefault();
                    console.log('🦷 Keyboard shortcut 8 pressed for dental base');
                    if (window.dentalBaseUI) {
                        window.dentalBaseUI.showBaseSelectionDialog(selectedModel);
                    } else {
                        console.error('❌ dentalBaseUI not available via keyboard shortcut');
                    }
                }
                
                if (e.key === '9') {
                    e.preventDefault();
                    console.log('🧭 Keyboard shortcut 9 pressed for orientation');
                    if (window.modelingToolsUI) {
                        window.modelingToolsUI.showOrientationDialog(selectedModel);
                    } else {
                        console.error('❌ modelingToolsUI not available via keyboard shortcut');
                    }
                }
                
                if (e.key === '0') {
                    e.preventDefault();
                    console.log('🔧 Keyboard shortcut 0 pressed for solidify');
                    if (window.modelingToolsUI) {
                        window.modelingToolsUI.showSolidificationDialog(selectedModel);
                    } else {
                        console.error('❌ modelingToolsUI not available via keyboard shortcut');
                    }
                }
            });
            
            console.log('🎉 DentalCAD Pro loaded successfully!');
        });

        // Setup event listeners for modeling tools
        function setupModelingToolsEventListeners(modelingTools) {
            let isProcessing = false;

            // Check backend status
            async function checkBackendStatus() {
                const statusElement = document.getElementById('backendStatus');
                const statusTextElement = document.getElementById('backendStatusText');
                
                if (!statusElement || !statusTextElement) return;

                if (modelingTools.isBackendAvailable()) {
                    statusElement.className = 'mb-4 p-3 rounded text-sm bg-green-800 text-green-200 border border-green-600';
                    statusTextElement.innerHTML = '✅ Python Backend Online - Advanced modeling available';
                    enableControls(true);
                } else {
                    statusElement.className = 'mb-4 p-3 rounded text-sm bg-yellow-800 text-yellow-200 border border-yellow-600';
                    statusTextElement.innerHTML = '⚠️ Python Backend Offline - Start the modeling service to enable advanced features';
                    enableControls(false);
                    
                    // Retry connection every 10 seconds
                    setTimeout(() => checkBackendStatus(), 10000);
                }
            }

            function enableControls(enabled) {
                const controls = [
                    'orientOcclusalUp', 'orientOcclusalDown', 'orientBuccalFront', 'orientLingualView',
                    'applyCustomOrientation', 'applySolidification'
                ];

                controls.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.disabled = !enabled;
                    }
                });
            }

            function updateStatus(message, type = 'info') {
                const statusElement = document.getElementById('modelingStatusText');
                if (statusElement) {
                    statusElement.textContent = message;
                }

                const statusContainer = document.getElementById('modelingStatus');
                if (statusContainer) {
                    statusContainer.className = `bg-gray-700 p-3 rounded text-sm ${
                        type === 'error' ? 'text-red-300' : 
                        type === 'success' ? 'text-green-300' : 
                        type === 'processing' ? 'text-yellow-300' : 'text-gray-300'
                    }`;
                }
            }

            async function applyOrientation(presetName) {
                if (isProcessing) return;

                if (!selectedModel) {
                    updateStatus('Please select a model first', 'error');
                    return;
                }

                isProcessing = true;
                updateStatus(`Applying ${presetName} orientation...`, 'processing');

                try {
                    const success = await modelingTools.applyOrientation(selectedModel, presetName);
                    
                    if (success) {
                        updateStatus(`✅ ${presetName} orientation applied successfully`, 'success');
                        render();
                    } else {
                        updateStatus('Failed to apply orientation', 'error');
                    }

                } catch (error) {
                    console.error('Orientation error:', error);
                    updateStatus(`Error: ${error.message}`, 'error');
                } finally {
                    isProcessing = false;
                }
            }

            async function applyCustomOrientation() {
                if (isProcessing) return;

                if (!selectedModel) {
                    updateStatus('Please select a model first', 'error');
                    return;
                }

                const x = parseFloat(document.getElementById('rotationX').value) || 0;
                const y = parseFloat(document.getElementById('rotationY').value) || 0;
                const z = parseFloat(document.getElementById('rotationZ').value) || 0;

                isProcessing = true;
                updateStatus(`Applying custom orientation (${x}°, ${y}°, ${z}°)...`, 'processing');

                try {
                    const success = await modelingTools.setCustomOrientation(selectedModel, x, y, z);
                    
                    if (success) {
                        updateStatus(`✅ Custom orientation applied: X:${x}°, Y:${y}°, Z:${z}°`, 'success');
                        render();
                    } else {
                        updateStatus('Failed to apply custom orientation', 'error');
                    }

                } catch (error) {
                    console.error('Custom orientation error:', error);
                    updateStatus(`Error: ${error.message}`, 'error');
                } finally {
                    isProcessing = false;
                }
            }

            async function applySolidification() {
                if (isProcessing) return;

                if (!selectedModel) {
                    updateStatus('Please select a model first', 'error');
                    return;
                }

                const thickness = parseFloat(document.getElementById('extrusionDepthValue').value) || 2.0;

                isProcessing = true;
                updateStatus(`Solidifying model with ${thickness}mm wall thickness...`, 'processing');

                try {
                    const success = await modelingTools.applySolidification(selectedModel, thickness);
                    
                    if (success) {
                        updateStatus(`✅ Model solidified with ${thickness}mm walls`, 'success');
                        updateFileList();
                        render();
                    } else {
                        updateStatus('Failed to solidify model', 'error');
                    }

                } catch (error) {
                    console.error('Solidification error:', error);
                    updateStatus(`Error: ${error.message}`, 'error');
                } finally {
                    isProcessing = false;
                }
            }

            // Orientation preset buttons
            document.getElementById('orientOcclusalUp')?.addEventListener('click', () => {
                applyOrientation('occlusalUp');
            });

            document.getElementById('orientOcclusalDown')?.addEventListener('click', () => {
                applyOrientation('occlusalDown');
            });

            document.getElementById('orientBuccalFront')?.addEventListener('click', () => {
                applyOrientation('buccalFront');
            });

            document.getElementById('orientLingualView')?.addEventListener('click', () => {
                applyOrientation('lingualView');
            });

            // Custom orientation
            document.getElementById('applyCustomOrientation')?.addEventListener('click', () => {
                applyCustomOrientation();
            });

            // Solidification
            document.getElementById('applySolidification')?.addEventListener('click', () => {
                applySolidification();
            });

            // Sync range and number inputs for wall thickness
            const thicknessRange = document.getElementById('extrusionDepth');
            const thicknessValue = document.getElementById('extrusionDepthValue');

            if (thicknessRange && thicknessValue) {
                thicknessRange.addEventListener('input', (e) => {
                    thicknessValue.value = e.target.value;
                });

                thicknessValue.addEventListener('input', (e) => {
                    thicknessRange.value = e.target.value;
                });
            }

            // Initial backend status check
            setTimeout(checkBackendStatus, 1000);
            
            // Debug loader availability
            console.log('🔍 Checking loader availability:');
            console.log('  - STLLoader:', typeof window.STLLoader);
            console.log('  - OrbitControls:', typeof window.OrbitControls);
            
            if (!window.STLLoader) {
                console.warn('⚠️ STLLoader not loaded yet, waiting...');
                setTimeout(() => {
                    console.log('🔍 Recheck - STLLoader:', typeof window.STLLoader);
                    console.log('🔍 Recheck - OrbitControls:', typeof window.OrbitControls);
                }, 2000);
            }
        }
    </script>
</body>
</html>

